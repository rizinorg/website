[{"content":"As developers, we think it is essential to have a building system that eases our work, allows us to compile Rizin quickly on a wide range of devices, is easy to understand and to modify, and provides a nice set of features one would usually expect from a full-fledged building system. Since its inception, Rizin has focused on improving its Meson build files and making its support first-class while deprecating the original building system used in radare2. In the following article, we will explain the reasons behind this choice and the key benefits of Meson.\nTL;DR  Meson is declarative and easy to understand Ninja is fast, no files are recompiled if not necessary Meson keeps your source directory clean with out-of-source builds Meson makes it easy to build and run multiple versions of Rizin Meson simplifies dependency handling and switching from internal dependencies to system-provided ones  A bit of context Historically radare2 has been compiled with the usual ./configure; make approach. This essentially consists of a shell script, configure, and a set of Makefiles. configure allows the user to customize the compilation and installation process performed by make by setting, for example, the destination directories where executables, libraries, etc. are installed on the system. It is also used to enable or disable specific features (e.g. the debugger) or to check for the existence of specific libraries, header files, functions, compiler or linker arguments.\nTo some, this may be very similar to what is done by Autotools. However, in radare2/Rizin case, configure is generated by another shell script, acr, by parsing a configure.acr file. acr is a tool developed by the original author of radare2, and it is an Autoconf replacement.\nDuring the years some attempts were made to introduce other build systems, like Jam and a NodeJS-based build system. It was only in 2017 that radare2 started introducing Meson. Since then, many people have improved this system to compile on several platforms and making sure it is (almost) feature-wise on par with the ACR/Make build system.\nRizin has chosen to deprecate the use of ACR/Make and switch to Meson as the main build system. We believe this will make the overall build process more standard, easy to understand, and easy to integrate with other tools/libraries. Other very valid alternatives such as CMake were considered, however we preferred to keep working with Meson, which was already tested and tried with Rizin for a long time, rather than starting completely from scratch with another build system.\nProblems with ACR/Make There are of course several reasons for this choice, so let\u0026rsquo;s first see what we have identified as the problems of the historical approach:\n ACR is essentially a one-person project, with mostly only radare2 and other radare-related tools using it. This by itself is not a bad thing, but it comes with the downside that you find no help or documentation online and if you have issues or missing features, you have to rely on one person only who understand its internals. Moreover, the features you find are usually just the ones used by radare2 project (e.g. not long ago, it was not possible to easily check if the compiler supported a particular compilation flag, because it was never necessary for radare2). configure script needs a sh shell, which makes it hard to use on platforms such as Windows. There are of course ways to use it, but they may involve installing MinGW or similar, which may not be ideal for Windows users who usually work within Visual Studio. Makefiles can be written in a very flexible way and they can be used to perform any sort of action, from simply compiling a C file to running scp, various scripts, and much more. Flexibility shall not be abused though. Otherwise, it may become hard to understand how things are actually done. For example, understanding how librz_io.so is compiled involves looking at the Makefile in libr/io, which includes config.mk that setups some variables based on other variables defined in the Makefile and then it includes rules.mk, which uses those variables to actually compile the library. Inside rules.mk you find, hidden with various environment variables, the commands used to build the object files, and then the library. You can look at the compilation command here, which we think is hard to grasp from a quick look even for people familiar with radare2/Rizin codebase (you may wonder where to find config.mk mentioned above: it is auto-generated). It is \u0026ldquo;low-level\u0026rdquo;, which means that the Makefiles define the specific commands, flags, and options that you have to use to actually compile a binary, a library, or an object file. This provides a lot of power, but it may also be overwhelming having to remember to add specific compilation/linking flags for compiling a single file. For example, it is not possible yet to compile radare2/Rizin within a directory with spaces in the name due to limitations within GNU Make. ACR/Make cannot be used as-is to compile Rizin on Windows systems.  What we like about the Meson Build System   It is declarative, which means you don\u0026rsquo;t have to remember or care about how to actually compile a shared library or a static library on Linux, Windows, BSD, etc. or how to link an executable with some other libraries or make sure include paths are right. As an example, look at this piece of meson.build:\nlibrary('io', ['file1.cpp', 'file2.cpp'], dependencies: [util_dep], install: true, soversion: rz_asm_lib.version() )   You don\u0026rsquo;t need to know how meson is going to build your library, but it is going to do it by compiling two source files (e.g. file1.cpp and file2.cpp), name the library io (e.g. on Linux the library would be called libio.so, but the full name and the extensions might be different on Windows) and give it the proper API version, make sure the dependency specified by util_dep, whatever it is, is used to compile this library, by adding the proper include paths and link directives.\n  It is fast. This is extremely important for developers, as while developing a feature or fixing a bug they may need to compile Rizin multiple times and we want this process to be as fast as possible. Meson/Ninja performs quite well compared to other build systems (https://mesonbuild.com/Simple-comparison.html). It forces you to list all source files used to compile a target and it is able to automatically compute other dependencies between targets. In ACR/Make, due to its complexity as implemented in radare2/Rizin and to the low-level approach, it is easy to mess with the dependencies between targets and to recompile multiple times the same files even when there are no changes. For example, until very recently, running make multiple times caused the recompilation of several objects even if no file was changed (in last few months this problem was caused by wrong dependencies of sdb, in the past due to wrong dependencies of the capstone target).\n  meson can run everywhere python3 can. This includes a very wide range of platforms nowadays. It automatically provides a very powerful scripting language, python, that you are guaranteed to find on the build machine. Moreover, it can be used with various backends, like Ninja, Visual Studio and Xcode, which means it can be used to generate a Visual Studio solution that you can import there.\n  It forces you to build out-of-source, meaning that no changes (mostly) will be done to your source directory, which must contain only the source files of your project and not be mixed with other auto-generated files like executables or object files. This also allows you to have the project compiled with different options or with slightly different code, cleanly separated in different directories.\n  Due to its declarative nature, it does not matter whether a dependency is in a path or another or if it comes from the system or it was bundled with the source code. You just define capstone_dep variable properly in one of your meson.build files and you reference it wherever it is needed, leaving all the details to meson itself. This encourages splitting the repository into sub-projects when it makes sense, in contrast with the ACR/Make system where even a small change to e.g. SDB path would require rewriting several Makefiles. If in the future some systems will ship their own version of SDB, we would just need to change few lines in the definition of sdb_dep to actually take the system library instead of the bundled one and no other place would need to be changed to make sure everything is compiled/linked with the right headers/libraries.\n  In case of problems with meson there is a healthy community out there ready to help you, a nice and extensive documentation and active developers that improve the system with new releases. New developers who want to work on our build system can easily find other examples online and have available documentation to get them up to speed.\n  Many complex low-level pure C projects recently switched to Meson: Mesa, Wayland, PipeWire, QEMU, and many others. We are not alone in this!\n  Examples of using meson Development process As a developer when you download Rizin, you can install it for your user in ~/.local, so you don\u0026rsquo;t need root access to install files. You can do this with meson --prefix=~/.local build; ninja -C build install. After that, you can change the source code however you need and then run ninja again with ninja -C build. Only the changed files are re-built.\nMoreover, running ninja by default builds files with explicit RPATHs, which means that the executables and libraries contain direct references to the paths of dependent libraries they are linked against so the loader can then always find them without having to specify LD_LIBRARY_PATH or similar. For this reason, most of the times you will not need to re-install the Rizin files, but while developing you can just run rizin from ./build/binrz/rizin/rizin.\nRPATH are not, of course, always good. Indeed they are usually removed during the installation process. However, when you install Rizin in a place that is not /usr, we have chosen to keep RPATHs to make the installation process as simple as possible, without requiring users to mess with their environment to make sure the binaries can find the proper libraries. Packagers, who usually use /usr as a prefix, should not be affected by this decision, but they can anyway disable it by specifying -Dlocal=false when running meson.\nReviewing a PR and testing changes When testing a PR with a fix or comparing multiple changes, you need to have access to multiple versions of Rizin. Doing this with ACR/Make is of course possible, but it usually involves installing everything in separated directories and making sure your environment variables (e.g. PATH, LD_LIBRARY_PATH, etc.) are correctly set. With meson, you can build one version (e.g. from dev branch) with meson --prefix=~/.local build-dev; ninja -C build-dev, then switch branch with git checkout my-other-branch and build Rizin again with meson --prefix=~/.local build-pr; ninja -C build-pr. Due to the RPATH used by default, as mentioned above, each build directory can be used without installation to actually run the Rizin tools. At that point, you can quickly compare the results of ./build-dev/binrz/rizin/rizin and ./build-pr/binrz/rizin/rizin.\nConclusion Of course it\u0026rsquo;s not all perfect with meson either. Right now the meson build system is missing some features that were only available with ACR/Make.\nTo uninstall Rizin you have to run ninja -C build uninstall from the same build directory you used to run the install step, otherwise, it will not uninstall files. However if during install step we add any custom installation script (e.g. to sign your rizin binary in macOS), there is no counter part to actually have an uninstall script. That said, nothing prevents us from having a custom target similar to what ACR/Makefile system does to manually remove, with a script, the installed files, but we believe proper file tracking should be done by distributions and packages.\nMeson is quite new and, although rare, you may find issues from time to time. That said, its community is healthy and active so you can count on them to fix these problems as soon as possible or provide help, also thanks to the many big projects that have switched to meson in the last years.\nAll in all, we hope to make it easier for our developers and users to build Rizin. We are trying to build a good Reverse Engineering Framework and we want to focus our efforts on this rather than dealing with the limitations of a niche build system.\nIf you find issues or find particular installation setups difficult or missing, feel free to open a bug in GitHub and we will be happy to either guide you through a solution or develop the fix according to our roadmap.\n","permalink":"https://rizin.re/posts/why-meson/","summary":"Why we switched to Meson/Ninja as our main build system.","title":"Why we chose Meson as our build system"},{"content":"When manually analyzing a complex binary, possibly over the course of days, weeks or even months, it is crucial to be able to keep track of the gained knowledge through annotations such as comments, function and variable names. As such, the tool one is working with also need to provide a reliable and future-proof way to save and restore this information. One of the biggest additions in Rizin surely is the new projects feature, which provides exactly this functionality in both rizin on the command line and Cutter. In this article, we would like to give an overview of how it was designed, what exactly it promises to you, as well as the current limitations you should be aware of when using it right now.\ntl;dr  Projects can be used in rizin using the Ps [\u0026lt;project.rzdb\u0026gt;] and Po \u0026lt;project.rzdb\u0026gt; commands and in Cutter through its regular user interface. Projects are currently in beta, including in any 0.x.y releases of Rizin, and will be considered stable starting with release 1.0.0.  Beta means that all functionality is implemented and ready to use, but there is no guarantee that the format itself will not further change slightly and thus maybe break loading a project saved right now in a future version of Rizin. Stable means that the format is finalized and all changes inside of it will come with migrations and tests ensuring that all projects saved before are still be loaded correctly.   Projects may be conceptually split into two parts: the binary that is being analyzed, and any info that has been put on top by automatic analysis or the user.  Saving and loading of all analysis data on top of a binary, including flags, functions, variables, types, comments is implemented. Automatic reloading of the underlying binary is currently limited to only a single binary available as a regular file, but this will be extended to arbitrarily complex IO mappings in the future. However, even with the current state, it is possible to manually reconstruct more complex mappings and then load any analysis data on top using the Poo \u0026lt;project.rzdb\u0026gt; command.    Wait, weren\u0026rsquo;t there already projects in Radare2 before? Indeed, there has been a projects feature in Radare2 since 2017. This has been removed entirely from Rizin and is now entirely replaced by the new implementation, which has been re-designed from scratch and shares no code with the old one.\nTo understand why such a radical change was necessary, let us take a closer look at how old projects were designed. They primarily consisted of a single rc file, which was a radare2 script containing regular commands that would reconstruct the session state when run. As an example, a part of such a script to load one function could look like this:\n\u0026quot;f main 127 0x080485f5\u0026quot; \u0026quot;af+ 0x080485f5 main s n\u0026quot; afb+ 0x080485f5 0x080485f5 54 0x08048655 0x0804862b afb+ 0x080485f5 0x0804862b 24 0x08048655 0x08048643 afb+ 0x080485f5 0x08048643 18 0x08048665 0xffffffffffffffff afb+ 0x080485f5 0x08048655 16 0x08048665 0xffffffffffffffff afb+ 0x080485f5 0x08048665 15 0xffffffffffffffff 0xffffffffffffffff We can see it is first creating a flag (f), then creating a function (af+) and finally adding basic blocks to it (afb+).\nWhile this general approach can work in theory, it comes with several implications:\n Commands can have side effects. As an example, until only very recently, the afb+ command would trigger a heavy function analysis loop after adding a basic block in some circumstances, creating variables, X-Refs and other information. The information coming out of this side effect would then mix with the rest of the restored session, resulting for example in unwanted variables being present after loading. Commands and their semantics can change over time. Simple changes include command name changes or the order of arguments, more complex ones may involve major restructuring of underlying concepts, thus requiring entirely different command sequences to achieve the same results. Of course, since the saving instance can not predict the future, it would be solely the responsibility of loading instance to account for such changes. However with the project being an unstructured sequence of commands that may not even be part of the codebase anymore at this point, performing such a migration is far from trivial and highly error-prone.  Moreover, before rizin\u0026rsquo;s new command parser was created, there was no formal specification of the command syntax. You can see in the above example that the first af+ command is enclosed in \u0026quot;...\u0026quot;, which is to account for cases such as the function name being ma;in where otherwise the ; would be interpreted as a separator for a new command, similar as in an SQL injection, eventually resulting in broken project loading. However, this quoting scheme still falls for names such as ma\u0026quot;in. As mentioned, this could have been eventually fixed using the new command parser, which has a well-defined escaping syntax, but it still has been the source of many bugs in the past.\nOn top of all these fundamental issues comes the fact that these projects were never tested apart from very few integration tests covering only a tiny fraction of the information potentially included in a session. All these aspects combined led to a high density of bugs and uncertainty when working with this feature. If you were very lucky, the project would save and load as expected. If you were less lucky, the loading would simply result in an error. But, and this has been the most likely case, if you were unlucky, the project would load seemingly correctly, but you would notice only later that the loaded data was deeply corrupted.\nDespite some of these issues being theoretically possible to fix, the conceptual problems of using commands for projects remain. Because the ability to save a session is only even remotely useful when it can also be relied upon to always correctly restore it in the future, a different approach had to be taken here, hence requiring an entire rewrite of the feature. This new approach, detailed in the following section, takes concrete learnings from the mistakes of the previous approach and thus avoids all problems mentioned above right from the start.\nDesign Projects take a classic, fully declarative approach to store their information, saving and loading a direct dump of the internal state.\nSerialization All relevant modules and data structures now have serialization and deserialization functions added, commonly prefixed with rz_serialize_ and implemented in files called serialize_*.c, as for example serialize_flag.c in the case of flags.\nFor the target data structure, SDB is being used, which is a database that is also used in other parts of rizin. What makes SDB special is its simplicity: One SDB is simply a mapping from arbitrary string keys to string values, and multiple SDBs can be nested in a tree of namespaces. This restricted design makes SDB unsuitable for many applications, but for our projects it turned out to fit very well. Inside such an SDB, when more complex structures are needed, JSON is used. This combination of well-defined formats means we can rely on them and forget about escaping or sanitizing strings in our actual serialization code.\nFor example, the same function as in the previous example would now be serialized like this:\n/core/analysis/functions 0x80485f5={\u0026quot;name\u0026quot;:\u0026quot;main\u0026quot;,\u0026quot;bits\u0026quot;:32,\u0026quot;type\u0026quot;:4,\u0026quot;cc\u0026quot;:\u0026quot;cdecl\u0026quot;,\u0026quot;stack\u0026quot;:16,\u0026quot;maxstack\u0026quot;:32,\u0026quot;ninstr\u0026quot;:43,\u0026quot;bp_frame\u0026quot;:true,\u0026quot;bp_off\u0026quot;:8,\u0026quot;diff\u0026quot;:{},\u0026quot;bbs\u0026quot;:[134514165,134514219,134514243,134514261,134514277],\u0026quot;vars\u0026quot;:[{\u0026quot;name\u0026quot;:\u0026quot;argv\u0026quot;,\u0026quot;type\u0026quot;:\u0026quot;char **\u0026quot;,\u0026quot;kind\u0026quot;:\u0026quot;s\u0026quot;,\u0026quot;delta\u0026quot;:4,\u0026quot;arg\u0026quot;:true,\u0026quot;accs\u0026quot;:[{\u0026quot;off\u0026quot;:0,\u0026quot;type\u0026quot;:\u0026quot;r\u0026quot;,\u0026quot;sp\u0026quot;:4,\u0026quot;reg\u0026quot;:\u0026quot;esp\u0026quot;}]},{\u0026quot;name\u0026quot;:\u0026quot;var_8h\u0026quot;,\u0026quot;type\u0026quot;:\u0026quot;int32_t\u0026quot;,\u0026quot;kind\u0026quot;:\u0026quot;b\u0026quot;,\u0026quot;delta\u0026quot;:-16,\u0026quot;accs\u0026quot;:[{\u0026quot;off\u0026quot;:117,\u0026quot;type\u0026quot;:\u0026quot;r\u0026quot;,\u0026quot;sp\u0026quot;:18446744073709551608,\u0026quot;reg\u0026quot;:\u0026quot;ebp\u0026quot;}]}]} /core/analysis/blocks 0x80485f5={\u0026quot;size\u0026quot;:54,\u0026quot;jump\u0026quot;:134514261,\u0026quot;fail\u0026quot;:134514219,\u0026quot;traced\u0026quot;:true,\u0026quot;ninstr\u0026quot;:18,\u0026quot;op_pos\u0026quot;:[4,7,10,11,13,14,15,17,20,25,30,33,36,41,46,49,52],\u0026quot;stackptr\u0026quot;:16,\u0026quot;parent_stackptr\u0026quot;:0,\u0026quot;cmpval\u0026quot;:1} 0x804862b={\u0026quot;size\u0026quot;:24,\u0026quot;jump\u0026quot;:134514261,\u0026quot;fail\u0026quot;:134514243,\u0026quot;traced\u0026quot;:true,\u0026quot;ninstr\u0026quot;:9,\u0026quot;op_pos\u0026quot;:[3,6,8,11,12,17,20,22],\u0026quot;stackptr\u0026quot;:16,\u0026quot;parent_stackptr\u0026quot;:16} 0x8048643={\u0026quot;size\u0026quot;:18,\u0026quot;jump\u0026quot;:134514277,\u0026quot;traced\u0026quot;:true,\u0026quot;ninstr\u0026quot;:5,\u0026quot;op_pos\u0026quot;:[3,8,13,16],\u0026quot;stackptr\u0026quot;:16,\u0026quot;parent_stackptr\u0026quot;:16} 0x8048655={\u0026quot;size\u0026quot;:16,\u0026quot;jump\u0026quot;:134514277,\u0026quot;traced\u0026quot;:true,\u0026quot;ninstr\u0026quot;:4,\u0026quot;op_pos\u0026quot;:[3,8,13],\u0026quot;parent_stackptr\u0026quot;:16} 0x8048665={\u0026quot;size\u0026quot;:15,\u0026quot;traced\u0026quot;:true,\u0026quot;ninstr\u0026quot;:7,\u0026quot;op_pos\u0026quot;:[5,8,9,10,11,14],\u0026quot;parent_stackptr\u0026quot;:0} While this certainly is harder to read for humans, it follows a clearly defined structure and all relevant information can be extracted from it directly. This kind of serialization design now also allows unit tests to be written easily and in fact all currently implemented serializations already come with such tests, aiming to ensure that all internal state is correctly saved and loaded, down to even subtle details and corner cases.\nWhat you see above is already an example of how the serialization will eventually be saved to a file. It is a simple, text-based format that stores the SDB entries line by line and takes care of any necessary escaping. While such a text-based format may not be the most efficient representation, it turned out to be more than good enough for even larger projects and in addition has certain nice properties, which we will make use of further down. However, due to the simplicity of SDB, other file formats to store the same data are theoretically feasable too.\nVersioning An important aspect is that the possibility to correctly load a project will survive even significant updates of the software. To ensure this, a simple version-based migration approach is used: The project code contains a version number defined as RZ_DB_PROJECT_VERSION, which is simply an integer that is increased every time there is a change in the format. This number is then simply saved into every project\u0026rsquo;s metadata namespace.\nLater, when loading the same project in newer rizin that also has a higher internal project version number, it will be able to know exactly the kind of format that the old project was saved with and will be able to upgrade it by successively applying migrations, which will be implemented along every increase of the project version number.\nAt the current point in time, the version number is 1 and there are no migrations. This is because at the moment, the projects feature is considered to be in a Beta phase, allowing it to be tested thoroughly and still receive changes to the format that might turn out sensible without the additional engineering overhead of implementing migrations.\nThis means that right now, everybody is highly encouraged to test projects and report any issues that might come up, but be aware of the fact that compatibility with later rizin versions may not be guaranteed and might require small manual edits in the serialized file.\nThe Beta phase will continue throughout all 0.x.y versions of rizin and end by version 1.0.0 where projects will be considered stable, meaning that all projects should always be properly loaded in all future versions and if a case is discovered where this promise is not held, it will be considered a bug and shall be fixed.\nRe-loading of underlying binaries One of the trickiest aspects of serializing a rizin session is handling the actual underlying binary that is being analyzed. In fact, speaking of \u0026ldquo;the binary\u0026rdquo; in this context is a crude underapproximation of what is actually present in Rizin.\nIgnoring debug, three modules are working together to load files: RzIO provides a generic IO layer, which can map data coming from plugins in a 64-bit address space. RzBin takes raw files from RzIO, parses their binary file formats such as ELF or PE, also using an independent plugin for each, and eventually provides information how to then lay out the contained sections in RzIO again, along with a list of symbols and other information parsed from the binary. RzCore controls how these modules are created and work together.\nThis design makes rizin\u0026rsquo;s loading mechanism very powerful and flexible, but imposes certain challenges on serialization: How to handle all the different IO plugins? Next to the one that simply loads a regular file, there are plugins for files in zip, malloc, http, shared memory, \u0026hellip; that all need individual reconstruction logic. For regular files, how to relocate the actual file when the project is moved to another machine? From RzBin, should the symbols information also be serialized or re-parsed?\nBecause this part needs to be designed properly first and might even require some refactoring in the respective modules, its implementation has been postponed for now. But the preliminary, rough plan is the following: Every IO plugin itself provides callbacks for (de)serialization of maps created with it. All IO maps are serialized to the file using these callbacks. Information in RzBin will not be serialized but re-parsed on top of the deseralized IO maps.\nHowever, despite this full implementation being postponed, a very simple temporary solution has been implemented, which is strictly limited to the case where only a single binary is loaded from a regular file with the default loading settings, i.e. without explicitly specifying the base address for example. This makes it possible to use projects conveniently right now for the majority of use-cases. More complex cases are also already possible, as long as the loading process is done manually and the project is then loaded on top using the Poo \u0026lt;file.rzdb\u0026gt; command, as shown in the following section.\nUsage Saving and loading projects from rizin is as simple as it can be:\n[0x00000000]\u0026gt; P? Usage: P\u0026lt;so?\u0026gt; # Project management | Ps [\u0026lt;project.rzdb\u0026gt;] # Save a project | Po \u0026lt;project.rzdb\u0026gt; # Open a project | Poo \u0026lt;project.rzdb\u0026gt; # Open a project on top of currently loaded binaries Use Ps [\u0026lt;project.rzdb\u0026gt;] from a running session to save it and Po \u0026lt;project.rzdb\u0026gt; to discard the current session and load the saved one. Alternatively, a project can also be loaded directly when starting rizin like rz -p project.rzdb.\nPo and -p will also take care of loading the single, underlying binary as explained in the previous section. If this is not desired, you can use the Poo \u0026lt;project.rzdb\u0026gt; command to keep all current state of IO mappings and parsed binaries in place and only load the analysis information on top.\nIn Cutter, simply use the File -\u0026gt; Save Project... menu entry or Ctrl+s shortcut to save and the Projects tab in the initial dialog to open a project:    Cutter will also ask you to save the project before quitting so no work will get lost by accident.\nFor the case explained before, where the project depends on more complex mappings than a single binary file, or if the same project should be loaded on top of another binary, the Poo \u0026lt;project.rzdb\u0026gt; can be used. For example, this is how a project can be loaded on top of two files:\n$ rizin -- # start rizin without any file [0x00000801]\u0026gt; on crackme.bin 0x7ff # load first file at 0x7ff [0x00000801]\u0026gt; on kernal.bin 0xe000 # load second file at 0xe000 [0x00000801]\u0026gt; Poo crackme.bin.rzdb # load project on top [0x00000815]\u0026gt; pd 1 # disassemble inside the first file 0x00000815 jsr CHROUT_in_kernal ; this is a call from crackme.bin into kernal [0x00000815]\u0026gt; pd 1 @ CHROUT_in_kernal # disassemble inside the second file ;-- CHROUT_in_kernal: 0x0000ffd2 jmp (0x0326) Version Control and Collaboration If you have used Ghidra before, you might have come across its \u0026ldquo;shared project\u0026rdquo; and Ghidra server, which are its strong, built-in features for collaborative reverse engineering with version control. Rizin takes a different approach to provide this functionality that is more in line with its UNIX-like focus. It does not implement version control itself, but instead creates project files in a way that they can work well with existing version control systems like git, which are well-tested and likely to already be familiar for users.\nBeing text files where independent content is generally split by lines, git already knows how to deal with tracking differences and merging for these files most of the time. This is for example a diff of a project where the current seek was changed and a comment added:\ndiff --git a/megabeets_0x1.rzdb b/megabeets_0x1.rzdb index 9c828f4..aed7e64 100644 --- a/megabeets_0x1.rzdb +++ b/megabeets_0x1.rzdb @@ -4,7 +4,7 @@ version=1  /core blocksize=0x100 -offset=0x8048370 +offset=0x8048600  /core/analysis @@ -158,6 +158,7 @@ watcom=cc  0x804859a=[{\u0026#34;type\u0026#34;:\u0026#34;t\u0026#34;,\u0026#34;str\u0026#34;:\u0026#34;char *dest\u0026#34;}] 0x80485db=[{\u0026#34;type\u0026#34;:\u0026#34;t\u0026#34;,\u0026#34;str\u0026#34;:\u0026#34;const char *s2\u0026#34;}] 0x80485e2=[{\u0026#34;type\u0026#34;:\u0026#34;t\u0026#34;,\u0026#34;str\u0026#34;:\u0026#34;const char *s1\u0026#34;}] +0x8048600=[{\u0026#34;type\u0026#34;:\u0026#34;C\u0026#34;,\u0026#34;str\u0026#34;:\u0026#34;I am putting a comment here!\u0026#34;}]  0x8048609=[{\u0026#34;type\u0026#34;:\u0026#34;t\u0026#34;,\u0026#34;str\u0026#34;:\u0026#34;const char *s\u0026#34;}] 0x8048619=[{\u0026#34;type\u0026#34;:\u0026#34;t\u0026#34;,\u0026#34;str\u0026#34;:\u0026#34;const char *s\u0026#34;}] 0x8048646=[{\u0026#34;type\u0026#34;:\u0026#34;t\u0026#34;,\u0026#34;str\u0026#34;:\u0026#34;const char *s\u0026#34;}] Examining these json-based diffs surely is not be the most convenient way to view differences for every user, but it provides a working compromise between readability for both humans and software at the same time without requiring any programs except git up to this point. In addition, we are investigating implementing custom diff- and mergetools that could be integrated into git and are fully aware of the meaning of data in project files to present and merge differences in the best way possible while still relying on an existing version control system.\nRegarding the binary that is being analyzed in a project, if desired, it can also be put into the same git repository as the project. Since projects contain a reference to the binary file relative to the project file, it can still be re-loaded when moved to another machine.\nConclusion We hope you will enjoy using rizin with its new projects feature. If you are interested, we highly encourage you to try it out, put it through its paces, and report any potentially upcoming issues, so we will be able to iron them out until the end of the beta phase!\n","permalink":"https://rizin.re/posts/introducing-projects/","summary":"An overview of the new projects feature in Rizin to save and load reversing sessions. Its design, promises and future.","title":"Introducing Projects in Rizin"},{"content":"We are excited to announce Rizin â€” a free and open-source Reverse Engineering framework, providing a complete binary analysis experience with features like Disassembler, Hexadecimal editor, Emulation, Binary inspection, Debugger, and more.\nRizin is a fork of radare2 with a focus on usability, stability, and working features, which strives to provide a welcoming environment for developers and users alike. Rizin was founded by a group of the core developers of radare2 and Cutter who contributed to the project in one way or the other in the past years and together constructed the Core group of radare2. With the establishment of Rizin, we are committed to creating an environment and a project which will be aligned with our values and vision.\nDuring recent years, the environment that was created in radare2 was one where many of us felt stressed, disrespected, and unwelcome. Moreover, the number of users of radare2 grew every year, and we held the ultimate responsibility to provide them a stable, usable framework. As the core developer team, we have come to the conclusion that it is impossible for us to continue to pursue the goal of making radare2 better under the current circumstances and environment, and we decided to move forward on our own and fork the project. Cutter, the Graphical User Interface for radare2, and its entire team will also join Rizin and will use it as its backend.\nRizin is a newborn project that was created from radare2, hence more and more changes and differences will appear over time. A lot of efforts were put into improving our workflows, putting more tests in place, improving the API, removing redundant features, and more. We hope to provide better consistency between releases, making the framework more trustworthy to users.\nWe are also working to create a more inclusive and diverse community that will be inviting for new contributors and users. As an initial step, we adopted a Code of Conduct that we believe is aligned with our values and with the community we want to create around Rizin.\nFinally, we know and understand that now it is our turn to prove that Rizin can become a tool you can trust and enjoy using, and a community in which you feel welcome. We invite you to read our answers to your Frequently Asked Questions and join our communities on Mattermost and other chat platforms.\n","permalink":"https://rizin.re/posts/announcing-rizin/","summary":"We are excited to announce Rizin â€” a free and open-source Reverse Engineering framework, providing a complete binary analysis experience.","title":"Announcing Rizin! ðŸŽ‰"},{"content":"Who are you? We are a group of developers and security enthusiasts who contributed to radare2 in one way or the other in the past years. Some of us got involved with radare2 up to 8 years ago. We were, together with pancake â€” the original author â€” the maintainers of the radare2 project. We developed, handled issues, pull requests, review, CI and more. Some of us are the team who lead and maintain the Cutter project, a popular Graphic User Interface for the radare2 project. Among others, we started the development and integration of popular decompilation plugins for radare2 such as r2ghidra and r2dec.\n Why did you fork radare2? During the years, the direction that radare2 was led to was not aligned with what we believed is the best for the project and the community. These disagreements covered many of the aspects involved in creating an open source project â€” technical, interpersonal, and managerial.\nWith time, the environment that was created was one where many of us felt stressed, disrespected, and unwelcome. An environment that for years affected users, contributors, and core members.\nRadare2 as a project evolved and couldn\u0026rsquo;t anymore be treated as a toy tool. With the number of users growing every year, we are in the ultimate responsibility to provide them a stable, usable framework. As the core developer team, we have come to the conclusion that it is impossible for us to continue to pursue the goal of making radare2 better under the current circumstances and environment.\nIt is natural for Open Source projects to separate to different journeys with different visions. We all want to participate and contribute to projects we are passionate about, which we believe in, feel safe and welcome, and enjoy working on. For the aforementioned reasons and others, we believe that it is better for us to move forward on our own and fork the project.\n What are the differences between Rizin and radare2? Rizin is a new born project that was created from radare2, hence more and more changes and differences will appear over time. With the establishment of Rizin, we are committed to create an environment and a project which will be aligned with our values and vision for an open source project and community.\nWe see it as our ultimate responsibility to provide the users with a stable and usable program that they can rely on. We will put efforts on releasing stable versions of Rizin and improving our test suite.\nIt is also in our obligation to create an environment where developers, contributors and users feel welcome and safe. For this, we put in place multiple instruments that will allow us to enforce such behavior. We adopted the Contributor Covenant Code of Conduct as we believe it is aligned with our values and with the community we want to create around Rizin. We will follow the code of conduct and enforce it on our different platforms. We started efforts of cleaning the source code from phrases that can\u0026rsquo;t be part of the environment we want to create. In addition, we will put efforts in creating a more inclusive and diverse community and welcome new contributors.\nTechnically speaking, Rizin already contains many changes that do not exist in radare2. Some of them are noted below:\n New Projects: we replaced the existing project functionality with a new one, developed entirely from scratch, that is based on serialization of existing objects instead of replication of commands. A blog post about this new feature will soon be published, so stay tuned if you want to know more! Removal of less tested/stable features: As we strive to provide a stable tool that you can trust, we chose to remove some features that we believe are not widely used, are old or are not tested at all and thus do not provide any value in their current state. This includes features such as the embedded WebUI, m commands, old projects, the pdc command, T commands, and others. Switch to Git submodules instead of copy-pasted code: this will allow us to better track the external code used in Rizin. Deprecation of ACR/Makefile build system in favor of Meson: experience has shown that a more declarative approach as used by Meson is easier to maintain and understand. Although at the moment, the ACR/Makefile build system contains some features that Meson in Rizin is missing, it is also slow (in terms of compilation time), complicated to edit and does not support out-of-source builds. If more additions are needed, we will be able to implement them in Meson. New shell behavior and overall commands handling: We recently developed in radare2 a new way to parse user commands, register them and develop them. This feature is called cfg.newshell and it will both make the user experience more consistent and the developer experience smoother. For these reason we have improved and enabled this by default in Rizin. We will publish a separate blog post about this soon!   What will happen to radare2 now? We don\u0026rsquo;t know. radare2 is a popular project with many contributors and users. The maintainer of radare2 will decide how things will proceed. Such a big move will naturally cause changes and we wish to work together to resolve them while causing the least amount of discomfort to the members of the radare2 community and the users.\nWe wish the radare2 project the best of luck.\n What about Cutter? The Core team of Cutter, who was also a part of radare2 Core team, left radare2 and co-founded Rizin. Following this, Cutter is switching from radare2 to Rizin as its backend. For the users of Cutter, nothing major should change. Development on Cutter will continue as usual. Changes in the organization and policies (e.g, Code of Conduct) will also apply to Cutter. Radare2 may or may not fork Cutter back to support radare2 instead and that is up to the radare2 maintainers.\n Will you contribute to radare2? As we are forking radare2, we would stop the contribution to the original project, though we expect patches to be imported from one project to the other for some time. In some cases, like a discovery of security vulnerabilities in mutual code, we would love to notify the radare2 team so users of the project will be protected.\n Can I take part and contribute to Rizin? Absolutely! We are thrilled to help you start and join Rizin. Please read our initial documentation for new contributors. Please join our Mattermost chat or #rizindev IRC channel on freenode! We hope to create better on-boarding guides for new contributors in the coming months, but for the meantime, we are here for any question you have.\n What actions will you make to keep Rizin a safe environment for contributors and users? The Rizin organization believes that contributors, developers and users should enjoy their time around the community and feel safe and welcome. We adopted a Code of Conduct that we believe is aligned with our values and with the community we want to create around Rizin. We will enforce it on our different platforms.\nWe started efforts of cleaning the source code from offensive phrases and comments. In addition, we will put efforts in creating a more inclusive and diverse community and welcome new contributors.\nFinally, we created the concept of teams that will be responsible for different aspects of Rizin. Such teams will also include a Community team that, among other things, will be an address for requests and complaints from community members.\n What is the future of Rizin? We intend to make Rizin a stable project you can trust for your reverse engineering tasks and a welcoming environment where people can work together on something they care. We will release a roadmap with the features we want to work on and the direction we will take. In the short run, you can expect refinements to the new projects and to the shell.\n How to pronounce \u0026ldquo;Rizin\u0026rdquo;? Thanks for asking!  Your browser does not support the audio element.   I have more questions, where can I ask? We would love to answer your question. You can send us a message on Mattermost or email us. Please note that we do not guarantee to answer all questions, as some topics are personal or we prefer to keep for ourselves.\n ","permalink":"https://rizin.re/posts/faq/","summary":"Who are you? Why did you fork radare2? What will happen to Cutter now? Our answers to your frequently asked questions.","title":"Frequently Asked Questions"},{"content":"Our Pledge We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.\nWe pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.\nOur Standards Examples of behavior that contributes to a positive environment for our community include:\n Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community  Examples of unacceptable behavior include:\n The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting  Enforcement Responsibilities Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.\nCommunity leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.\nScope This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.\nEnforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at moderation@rizin.re. All complaints will be reviewed and investigated promptly and fairly.\nAll community leaders are obligated to respect the privacy and security of the reporter of any incident.\nEnforcement Guidelines Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:\n1. Correction Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.\nConsequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.\n2. Warning Community Impact: A violation through a single incident or series of actions.\nConsequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.\n3. Temporary Ban Community Impact: A serious violation of community standards, including sustained inappropriate behavior.\nConsequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.\n4. Permanent Ban Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.\nConsequence: A permanent ban from any sort of public interaction within the community.\nAttribution This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\nCommunity Impact Guidelines were inspired by Mozilla\u0026rsquo;s code of conduct enforcement ladder.\nFor answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.\n","permalink":"https://rizin.re/code-of-conduct/","summary":"Rizin\u0026rsquo;s Code of Conduct","title":"Code Of Conduct"},{"content":"","permalink":"https://rizin.re/community/","summary":"community","title":"Community"},{"content":"","permalink":"https://rizin.re/teams/community/","summary":"","title":"Community Team"},{"content":"","permalink":"https://rizin.re/teams/core/","summary":"","title":"Core Team"},{"content":"","permalink":"https://rizin.re/teams/cutter-core/","summary":"","title":"Cutter Core Team"},{"content":"","permalink":"https://rizin.re/teams/distributions-and-packaging/","summary":"","title":"Distributions and Packaging Team"},{"content":"","permalink":"https://rizin.re/teams/documentation/","summary":"","title":"Documentation Team"},{"content":"TL;DR Jump to the Ideas list.\nIntroduction Each year since 2015, we have participated in Google Summer of Code as the Radare2 project and accomplished many goals. You can read more on the Radare2 - GSoC 2020 page. This year we participate as a fork - Rizin, but effectively continuing the same process and the same mentors.\nMentors Members of the Rizin and Cutter core teams have volunteered to guide students for GSoCâ€™21. They were already guiding the students for the GSoC and RSoC in past years as part of the Radare2 project. Please feel free to reach out to any of them in case you need any help in selecting a project.\n Anton Kochkov IRC: xvilka \u0026ndash; @akochkov Riccardo Shirone: ret2libc Florian MÃ¤rkl tg: @thestr4ng3r \u0026ndash; @thestr4ng3r Antide Petit IRC/tg: xarkes \u0026ndash; @xarkes_ Itay Cohen tg: @Megabeets @Megabeets_ Giovanni Dante Grazioli tg: @deroad @der0ad Yossi Zapesochini tg: @yossizap And many others  Development methodology Currently, all repositories are hosted on GitHub main organization account, bugs are tracked on GitHub issues too. We are mostly using our own Mattermost instance, IRC, and Telegram) for communication. We have a testsuite (that is running on GitHub Actions, Travis CI, AppVeyor and SourceHut) to test and verify that all the features are still working and that a pull requests or commits don\u0026rsquo;t break anything, to ensure the support of different operating systems (Linux, MacOS, Windows, FreeBSD, OpenBSD), different architectures (x86/x86_64, ARM64, PowerPC, SystemZ), and to find regressions. We encourage contributors to write test cases and documentation in order to verify the implementation and ensure that everything fits well together. For complex bugs and examples we\u0026rsquo;re using ASCIInema for recording the sessions.\nSee also our guides for corresponding projects:\n Rizin Contributing Guide and Developers Intro Cutter Contributing Guide and Developers Intro  For those who want to get introduced to the Rizin codebase and practices, we recommend to pick one of the easy issues for Rizin or Cutter to start with.\nLicense Rizin is modular: this means that it aims to make all the elements and features easily reusable from other projects. The choice of LGPL3 as a license is the minimum requirement to get code merged in Rizin. Contributors can choose Apache, BSD, MIT, Public Domain, or other similar licenses. The reason to exclude GPL as a valid license for the project is because we aim to support proprietary software that uses Rizin, while protecting our free codebase.\nInstructions for students It is a requirement that students who want to apply to the Rizin project for the Google Summer of Code 2021 should submit a small pull request accomplishing one of the microtasks (see below) as part of their application. Though you can also choose any of the GitHub issues for Rizin if they are big enough to be a qualification task, and still small enough to be finished no more than in a couple of weeks.\nProgramming languages Most of Rizin is written in C (conforming C99 standard) and hence we expect students to be familiar with C programming language. For some of our tasks or microtasks, such as collaborative RE or rz-pm, students should know the Go programming language. For the Cutter tasks, students should know C++ and Qt framework basics.\nRecommended steps  Read Google\u0026rsquo;s instructions for participating Grab any of the project from list of ideas that you\u0026rsquo;re interested in (or propose your own). Write a first draft proposal using Google Docs and our template and ask one of the mentors or administrators to review it with you. Submit it using Google\u0026rsquo;s web interface.  Student proposal guidelines  Keep it simple enough to fit in no more than a couple of pages. Try to be clear and concise in your writing. Try to split GSoC period into tasks, and each task into subtasks. It helps us to understand how you plan to accomplish your goals, but more importantly, it\u0026rsquo;ll help you to understand the task deep enough before starting, and prioritize important things to do first. Please, note, how much time a day/week you are able to spend on this project. Specify your timezone, since so we can assign you a mentor in the same one, to ease communication. Submit your proposal early, not in the last minute! Be sure to choose a â€œbackupâ€ idea (the second task you want to do), so that conflicts (two students for one task) can be resolved.  Project Ideas Rizin Type Analysis Improvements Currently we have types support in Rizin, including basic (low-level) ability to edit type with pf and higher-level, C-like types with t command. It is possible to parse the C type definition from C headers for example, or load from \u0026ldquo;precompiled\u0026rdquo; SDB file. The goal of this task is to integrate complex types like Classes handling into the rizin analysis loop, including automatic inference and suggestions. Some basic type inference is already implemented as a part of aft and afc commands, and analysis.types.* configuration options and can be used as a reference.\nTask  Integrating C++/ObjC/Swift/etc vtables analysis with types information Improve support of the constrained types Improve the ability to autosubstitute structure offset where possible (e.g. when you specified function parameter type and it uses it inside) Improve the type inference based on function arguments types, function return types and callgraph  Skills Student should know C as well as be familiar with basics of the program analysis.\nDifficulty Hard\nBenefits for the student Student will understand modern program analysis problems related to type inference, understand low level details on how compilers produce native code from OOP concepts, and will meet the most common reverse engineering task in its advanced incarnation.\nAssess requirements for midterm/final evaluation  1st term: Loading classes, methods and inheritance information and integrating loaded information into the analysis loop, types, av, t, andpf commands. Final term: Additional type propagation and inference based on the loaded information, documentation in the Rizin book and tests.  Mentors  xvilka thestr4ng3r  Links/Resources  Type Analysis Improvements Project VTable detection and parsing Constrained types enhacements TIE: Principled Reverse Engineering of Types in Binary Programs HexRaysCodeXplorer Virtuailor - vtables reconstruction based on runtime information Pharos - types inference with Prolog  CPU/Platform profiles While instruction set defines architecture, it is common that particular CPU or SoC models implement only a subset of it or extend it with custom instructions and registers. Moreover, various SoC modifications can define peripheral devices interaction through ports (rare), registers or MMIO spaces. All this helps the reverse engineering process, because a lot of the code will make sense upon a glance once you see it accesses certain registers (if named) or peripheral devices (when MMIO area is defined). A common example is SVD loading for ARM architecture.\nTask  Implement support for CPU profiles Implement support for platform profiles Add support for register and MMIO specific setups Integrate these in analysis loop, handling register and memory accesses. Implement tests and documentation in Rizin book Provide an API for setting these values from rz-pipe and lang-* plugins  Skills Student should know C and understand basics of the hardware platforms, architectures and chips.\nDifficulty Medium\nBenefits for the student The student will improve familiarity with reverse engineering for various architectures and platforms, along with the improving the efficiency of Rizin.\nBenefits for the project Huge benefits for end users in UX and better support for extension.\nAssess requirements for evaluations  1st term: CPU and platform profiles, some most common profiles, integration with the analysis loop Final term: Support for more platforms, regression and unit tests, documentation (including Rizin book).  Mentors  xvilka deroad  Rz-diff improvements Rizin has had the ability to perform binary diffing for over a decade. Nevertheless the support is quite basic and there is room for improvement. One of the most important tasks is to deepen the integration with analysis loop. Integration with the analysis loop will allow Rizin to find and highlight the difference between arguments count, local variables count, their types and other analysis metainformation. The next big task is to modernize rz-diff (and corresponding parts in RCore) in terms of performance and user interface. And of course - cover the rz-diff and rizin diffing features with regression tests and unit tests.\nTasks  Support diffing of the different parts of the same buffer/file Split view for hexadecimal view and disassembly diffing mode Improve the integration with analysis (variables and types differences) Integrate ESIL and decompilation (rz-ghidra, jsdec) pseudocode as an options for binary diffing Implement the most important diffing strategies from Diaphora Write the test cases for Rizin regression tests and improve the results.  Skills Student should know C as well as be familiar with basics of the program analysis. Having an experience with other binary diffing software is a plus.\nDifficulty Medium\nBenefits for the student Student will understand modern program analysis problems in application to binary diffing, and how to improve the performance of patch analysis.\nBenefits for the project This feature will make Rizin usable for day-to-day patch analysis of modern software, as well as improve the automation and performance of this task.\nAssess requirements for midterm/final evaluation  1st term: rz-diff/rizin should support highlighting types, arguments, and variables differences between functions. Fina term: Implement split-view for hex, disassembly, and graph modes. Their interface and performance improvements. Write the regression tests for all implemented features, add the documentation in Rizin book.  Mentors  xvilka Megabeets  Links/Resources  rz-diff-labeled issues Signature-labeled issues Cutter: Diffing interface feature request #1104 PatchDiff2 BinDiff Diaphora SimHash  Exploitation capabilities improvements Since modern architectures are now enforcing W^X, exploiters are using ROP. (Un)fortunately, building ROP chain by hand can be tedious, this is why some tools can be used to ease this construction: ImmunityDBG has mona.py, there is also ROPgadget and dropper.There exist even tools that can generate ROP chains automatically, for example exrop. It\u0026rsquo;s a shame that despite having ESIL, Rizin doesn\u0026rsquo;t have something similar yet. One of the possible solutions would be to build an external plugin or tool which will reuse power of librz and rz-gg. Moreover it makes sense to think about SROP, COOP and BROP support.\nThe rz-gg tool while has the ability to create a custom shellcode has the outdated database of the shellcodes, so updating them is crucial for the tool to be relevant.\nTask  Update the shellcodes database, imrove rz-gg features and documentation Implement a ropchain syntax parser that uses rz-gg or a custom DSL, something like:  register reg1 = 0; register reg2 = whatever; register reg3 = reg1 + reg2; system(reg3); Write a compiler which uses SMT solver (like Z3 for example) to produce the ropchain. Support main architectures - x86, ARM, MIPS, PowerPC  Skills The student should be comfortable with the C language, know some assembly and a high-level language. Also, knowing a little bit of automatic binary analysis wouldnâ€™t hurt.\nDifficulty Advanced\nBenefits for the student The student will improve their skills in software exploitation and solvers.\nBenefits for the project This feature would greatly help during exploits development, and people would be able to ditch mona.py for Rizin ;)\nAssess requirements for evaluation  1st term: Creating the language for defining the ROP chain semantics and integrating it with SMT solver Final term: Working ropchain compiler, covered by tests and documented in the Rizin book.  Mentors  xvilka ret2libc  Links/Resources  ROPGadget Ropper Angrop ROPC exrop roper2 mona.py from corelan Hunting for ROP Gadgets in Style (2012) dropper a BARF-based rop chain generator Materials about the exloitation workshop at Hack.lu 2014 Slides for the exploitation part of workshop at Hack.lu 2015 RzEgg related bugs  Cutter Plugins and Python High Level API We currently don\u0026rsquo;t have API almost for plugin authors to use. We need to improve a lot of things about our Plugins support and take it few steps ahead.\nTask  Expose everything Cutter can offer for plugins authors. This includes high level API, integration of the plugin management etc. Accessing everything from Python (like Blender) - see issue #1662 Python integration and IPython console.  Skills The student should be comfortable with the C++ and Python languages, and be familiar with Qt framework\nDifficulty Advanced\nBenefits for the student The student will gain an experience of creating a suitable API for scripting graphical interface programs.\nBenefits for the project It will greatly improve the scripting experience, will make API more consistent and will ease creating Cutter plugins by the community. Moreover, it will simplify testing of the Cutter features.\nAssess requirements for midterm/final evaluation  1st term: Design of the high level API and required Rizin changes. Review and implement all missing API functions that are accessible as interface controls. Final term: Implement the way to show the API when hovered over some interface control, create documentation.  Mentors  thestr4ng3r Megabeets  Links/Resources  SDB Module/API for Cutter Python/Jupyter integration Jupyter plugin for Cutter  Multi-Tasking and Event-driven architecture Cutter is a reverse engineering framework that is powered by Rizin. The information it gets about functions, strings, imports, and the analysis are all performed in Rizin and displayed in Cutter. Currently, Cutter is pulling information from Rizin only on demand. This is problematic because sometimes the user performs changes (via plugins, the console widget, and more), that are affecting the information from Rizin, but Cutter doesn\u0026rsquo;t know about these changes to apply the to the UI. For example, if a user will define a new function in a Python script or via the console widget by using the Rizin command af @ \u0026lt;addr\u0026gt;, Cutter will now show this new function in the Functions widget until the user will refresh the interface manually (edit -\u0026gt; Refresh Contents).\nIn addition, this task will also handle the analysis in the background feature, to allow the analysis performed by Rizin to happen while the interface is active.\nTasks The overall implementation of this task should start from Rizin by adding events to many of the functions. This can be done using rz_events. For example, add an even for function creating, for section creation, for flag deletion, for name changed, and more\n Add events to all the relevant functions inside Rizin Add support for these events in Cutter and refresh and update the relevant widgets per each event Support analysis in the background and allow the user to start its session while Rizin is analyzing (see #1856, #1574)  Skills The student should be comfortable with the C++ for Cutter and C for Rizin. The student should be familiar with Qt framework.\nDifficulty Advanced\nBenefits for the student The student will gain an experience of creating complex event-driven software in both C and C++ languages.\nBenefits for the project It will allow to work on big files effortlessly in Cutter, will improve analysis quality as well.\nAssess requirements for midterm/final evaluation  1st term: Implement events everywhere in the relevant places across Rizin code and event-driven interaction with Cutter. Final term: Add support for the Cutter interface refresh based on the events from Rizin, implement analysis in background.  Mentors  thestr4ng3r Karliss  Heap viewer We already have a nice heap (and memory map) parser and visualizer in Rizin (dm and dmh commands). After debugging becomes a first-class citizen in cutterland it would be awesome to have memory map and heap visualizations.\nTask  Expose Rizin API/commands for Cutter to use for visualization Design and implement heap navigation and inspection widgets Provide the integration with current debugging mode in Cutter Make the implementation work with both local (native) and remote debugging modes  Skills The student should be comfortable with the C++, and be familiar with Qt framework\nDifficulty Medium\nBenefits for the student The student will gain the understanding on how modern runtimes provide the heap for various programs, which will be beneficial for the binary exploitation skills.\nBenefits for the project It will greatly improve the debugging and reverse engineering experience for complex programs, also provides the way to design the exploitation techniques with the help of Rizin/Cutter.\nAssess requirements for midterm/final evaluation  1st term: Design and implement heap visualization widgets, add Rizin test and fixes Final term: Various bugfixes related to the heap inspection support on various platforms and allocators, tests and documentation.  Mentors  xvilka Megabeets  Links/Resources  Issue #1041 Heap Viewer plugin for IDA Pro Heap parsing for MacOS, tmalloc, jmalloc Dynamic Allocator Detection \u0026ldquo;heap\u0026rdquo;-marked Rizin issues  Diffing mode Binary diffing is one of the most common tasks for the reverse engineer. There are many various tools available, but most of them are either detached from the main RE toolbox or poorly integrated. Rizin provides basic diffing features out of the box with rz-diff tool, but Cutter has no interface to represent similar functionality.\nTask  Expose basic rz-diff features in the Cutter Create the interface to choose two files for diffing Create the way to show the differences in all main widgets:  Hexadecimal view Disassembly view Graph view Pseudocode view    Skills The student should be comfortable with the C++ language, and be familiar with Qt framework\nDifficulty Advanced\nBenefits for the student The student will gain an experience of creating efficient graphical interfaces.\nBenefits for the project It will greatly benefit the project since Cutter will be the only FOSS RE tool to provide this feature out of the box.\nAssess requirements for midterm/final evaluation  1st term: Expose the rz-diff features in the Cutter core and create the interface for opening files for diffing. Implement the diff modes for hexadecimal and disassembly views. Final term: Implement the diff modes for graph and pseudocode views, create the documentation.  Mentors  xvilka Megabeets  Links/Resources  Issue #1104 BinDiff Diaphora  Microtasks File formats Implementing the support for any new file format counts as a microtask. See New File-Format label for pending issues.\nDisassemblers and assemblers Implementing the support for any new architectire counts as a microtask. See New-Architecture label for pending issues.\nELF binary parsing. Rizin parses a lot of information about the ELF but doesn\u0026rsquo;t print everything. Thus, the improving the output of i* commands and rz-bin tool is important to match up with readelf:\n Add file section type and more flags for sections information (iS\tcommand) Add file offset and memory alignment for segments information (iSS command) Preserve valid names for symbols and sections  Moreover, some information about PLT stubs not being resolved correctly.\nAnalysis The current code analysis has many caveats and issues which need addressing. Fixing them and writing more tests is important to stabilize and enhance rizin\u0026rsquo;s analysis engine.\nSee these issues or the \u0026ldquo;Analysis\u0026rdquo; project on our GitHub dashboard.\nBasefind #413 There are plenty of external scripts and plugins for finding the most probable base for raw firmware images. Opening raw firmwares with rizin is a common use case, so it makes sense to implement it as a part of rizin core.\nHeap analysis #157 Currently Rizin has support for heap exploration and analysis, but the feature is still basic and can be improved. Additionally, other allocators can be added (MacOS, tmalloc, etc.), but this should be done after a proper refactoring, because heap analysis shouldn\u0026rsquo;t depend on the debugger backend, and we may be able to use different heap tools.\nClass analysis for C++/ObjectiveC/Swift/Dlang/Java #416 Analysis classes, accessible under the ac command, is a relatively new feature of rizin. They provide a way to both manually and automatically manage and use information about classes in the binary.\nDevirtualize method calls using class vtables #414 Consider the following call: call dword [eax + 0x6c] Let\u0026rsquo;s assume eax is the base pointer of a vtable we have saved in class analysis and we want to find out the actual address of the called method.\nSo there should be a command that takes the offset (in this case 0x6c) and looks up the actual destination. It should be possible to call this command with a specific class, so it only looks into its vtable, or without a class, so it gives a list of possible destinations for all vtables that are not too small for the offset.\nWhen that is implemented, one could also add a command that does the same thing, but automatically takes the offset from the opcode at the current seek.\nAdd classes list to Vb Vb already supports browsing bin classes. The same thing should be implemented for classes from analysis.\nSignatures Rizin has a good support for loading and creating signatures, but it is not yet complete, thus some problems remain, for example: #272.\nAs Rizin supports FLIRT signatures loading from IDA Pro, not all of them are supported yet - e.g. version 5 compression.\nRefactoring Use internal API instead of commands Currently, Rizin\u0026rsquo;s source code is rife with calls to rz_core_cmd()-like functions, that run the Rizin command. While it is a useful shortcut for developer, it makes a good source of the potential bugs in case of the command syntax or behavior change. If these changes happen they are invisible to the compiler, so it cannot warn on the changed syntax. It isn\u0026rsquo;t the case of changed function arguments count or type. Thus, all these calls eventually should be substituted with direct calls to the corresponding API functions. If there is no corresponding API funciton, then one should be created. Good examples of such cases are:\n Refactor Graph processing from commands to the API use Refactor Visual mode from commands to the API use Refactor Panels mode from commands to the API use  In general you can just search for rz_core_cmd pattern in any place inside librz/.\nImproving the uplifting of the code to IL Rizin has its own intermediate language - ESIL, but not yet support it for all architectures. So the task is to add ESIL support to any architecture, which doesn\u0026rsquo;t has it yet.\nMiscellanous Shell (dietline) improvements Currently Rizin uses its own readline-compatible implementation of the input handling in the embedded shell that is compact and portable between all supported platforms. It supports both Emacs and Vi modes, but not all bindings and features are supported. Some are omitted by choice, but some were simply not implemented. See the \u0026ldquo;dietline\u0026rdquo;-labeled issues.\nImproving regression suite and testing It is required to solve numerous issues, along with improving parallel execution and performance. Good example is to allow better filtering of the test types to run, for example to ignore debug tests. The next interesting idea is to setup and reuse Godbolt compilation engine for generating tests for different compilers and compilation options. There is even a command line tool for interacting with Godbolt - cce.\nAnother important part of the improving test suite is to cover more different formats and cases with expanding it. See the #114 issue with more details on how it can be done.\nRzGhidra There are many small issues in the decompiler output:\n String detection problem and one more. Show function arguments in calls pdgsd commands showing incorrect P-code Prioritize keeping vars with lower addresses Minor improvements for the SLEIGH plugin  Some of these issues might be related on how Rizin and RzGhidra integrate and might require changes in the Rizin side.\nAlso note, that most of these issues should be paired with the test to verify it will not break in the future.\n","permalink":"https://rizin.re/gsoc/2021/","summary":"TL;DR Jump to the Ideas list.\nIntroduction Each year since 2015, we have participated in Google Summer of Code as the Radare2 project and accomplished many goals. You can read more on the Radare2 - GSoC 2020 page. This year we participate as a fork - Rizin, but effectively continuing the same process and the same mentors.\nMentors Members of the Rizin and Cutter core teams have volunteered to guide students for GSoCâ€™21.","title":"GSoC 2021"},{"content":"","permalink":"https://rizin.re/teams/infrastructure/","summary":"","title":"Infrastructure Team"},{"content":"","permalink":"https://rizin.re/organization/","summary":"organization","title":"Organization"},{"content":"","permalink":"https://rizin.re/teams/package-manager-and-plugins/","summary":"","title":"Package Manager and Plugins Team"},{"content":"","permalink":"https://rizin.re/teams/security/","summary":"","title":"Security Team"}]