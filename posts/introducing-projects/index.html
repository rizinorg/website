<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Introducing Projects in Rizin | Rizin</title><meta name=keywords content="rizin,projects"><meta name=description content="An overview of the new projects feature in Rizin to save and load reversing sessions. Its design, promises and future."><meta name=author content="thestr4ng3r"><link rel=canonical href=https://rizin.re/posts/introducing-projects/><link href=/assets/css/stylesheet.min.608aafc4a643533f4ec6967b44e1560dd8623d1e10e96bc196999b8194900739.css integrity="sha256-YIqvxKZDUz9OxpZ7ROFWDdhiPR4Q6WvBlpmbgZSQBzk=" rel="preload stylesheet" as=style><link rel=icon href=https://rizin.re/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rizin.re/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rizin.re/favicon-32x32.png><link rel=apple-touch-icon href=https://rizin.re/apple-touch-icon.png><link rel=mask-icon href=https://rizin.re/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><link href=https://cdn.lineicons.com/2.0/LineIcons.css rel=stylesheet><link rel=stylesheet href=https://rizin.re/css/custom/rizin.min.680c6ca8d9f3b3fe6721cee593c808d0d6d77b79b0770aefbed2d9161082cd87.css><meta property="og:title" content="Introducing Projects in Rizin"><meta property="og:description" content="An overview of the new projects feature in Rizin to save and load reversing sessions. Its design, promises and future."><meta property="og:type" content="article"><meta property="og:url" content="https://rizin.re/posts/introducing-projects/"><meta property="og:image" content="https://rizin.re/images/rizin_preview.png"><meta property="article:published_time" content="2021-01-02T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-02T00:00:00+00:00"><meta property="og:site_name" content="Rizin"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rizin.re/images/rizin_preview.png"><meta name=twitter:title content="Introducing Projects in Rizin"><meta name=twitter:description content="An overview of the new projects feature in Rizin to save and load reversing sessions. Its design, promises and future."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Introducing Projects in Rizin","name":"Introducing Projects in Rizin","description":"An overview of the new projects feature in Rizin to save and load reversing sessions. Its design, promises and future.","keywords":["rizin","projects"],"articleBody":"When manually analyzing a complex binary, possibly over the course of days, weeks or even months, it is crucial to be able to keep track of the gained knowledge through annotations such as comments, function and variable names. As such, the tool one is working with also need to provide a reliable and future-proof way to save and restore this information. One of the biggest additions in Rizin surely is the new projects feature, which provides exactly this functionality in both rizin on the command line and Cutter. In this article, we would like to give an overview of how it was designed, what exactly it promises to you, as well as the current limitations you should be aware of when using it right now.\ntl;dr  Projects can be used in rizin using the Ps [] and Po  commands and in Cutter through its regular user interface. Projects are currently in beta, including in any 0.x.y releases of Rizin, and will be considered stable starting with release 1.0.0.  Beta means that all functionality is implemented and ready to use, but there is no guarantee that the format itself will not further change slightly and thus maybe break loading a project saved right now in a future version of Rizin. Stable means that the format is finalized and all changes inside of it will come with migrations and tests ensuring that all projects saved before are still be loaded correctly.   Projects may be conceptually split into two parts: the binary that is being analyzed, and any info that has been put on top by automatic analysis or the user.  Saving and loading of all analysis data on top of a binary, including flags, functions, variables, types, comments is implemented. Automatic reloading of the underlying binary is currently limited to only a single binary available as a regular file, but this will be extended to arbitrarily complex IO mappings in the future. However, even with the current state, it is possible to manually reconstruct more complex mappings and then load any analysis data on top using the Poo  command.    Wait, weren’t there already projects in Radare2 before? Indeed, there has been a projects feature in Radare2 since 2017. This has been removed entirely from Rizin and is now entirely replaced by the new implementation, which has been re-designed from scratch and shares no code with the old one.\nTo understand why such a radical change was necessary, let us take a closer look at how old projects were designed. They primarily consisted of a single rc file, which was a radare2 script containing regular commands that would reconstruct the session state when run. As an example, a part of such a script to load one function could look like this:\n\"f main 127 0x080485f5\" \"af+ 0x080485f5 main s n\" afb+ 0x080485f5 0x080485f5 54 0x08048655 0x0804862b afb+ 0x080485f5 0x0804862b 24 0x08048655 0x08048643 afb+ 0x080485f5 0x08048643 18 0x08048665 0xffffffffffffffff afb+ 0x080485f5 0x08048655 16 0x08048665 0xffffffffffffffff afb+ 0x080485f5 0x08048665 15 0xffffffffffffffff 0xffffffffffffffff We can see it is first creating a flag (f), then creating a function (af+) and finally adding basic blocks to it (afb+).\nWhile this general approach can work in theory, it comes with several implications:\n Commands can have side effects. As an example, until only very recently, the afb+ command would trigger a heavy function analysis loop after adding a basic block in some circumstances, creating variables, X-Refs and other information. The information coming out of this side effect would then mix with the rest of the restored session, resulting for example in unwanted variables being present after loading. Commands and their semantics can change over time. Simple changes include command name changes or the order of arguments, more complex ones may involve major restructuring of underlying concepts, thus requiring entirely different command sequences to achieve the same results. Of course, since the saving instance can not predict the future, it would be solely the responsibility of loading instance to account for such changes. However with the project being an unstructured sequence of commands that may not even be part of the codebase anymore at this point, performing such a migration is far from trivial and highly error-prone.  Moreover, before rizin’s new command parser was created, there was no formal specification of the command syntax. You can see in the above example that the first af+ command is enclosed in \"...\", which is to account for cases such as the function name being ma;in where otherwise the ; would be interpreted as a separator for a new command, similar as in an SQL injection, eventually resulting in broken project loading. However, this quoting scheme still fails for names such as ma\"in. As mentioned, this could have been eventually fixed using the new command parser, which has a well-defined escaping syntax, but it still has been the source of many bugs in the past.\nOn top of all these fundamental issues comes the fact that these projects were never tested apart from very few integration tests covering only a tiny fraction of the information potentially included in a session. All these aspects combined led to a high density of bugs and uncertainty when working with this feature. If you were very lucky, the project would save and load as expected. If you were less lucky, the loading would simply result in an error. But, and this has been the most likely case, if you were unlucky, the project would load seemingly correctly, but you would notice only later that the loaded data was deeply corrupted.\nDespite some of these issues being theoretically possible to fix, the conceptual problems of using commands for projects remain. Because the ability to save a session is only even remotely useful when it can also be relied upon to always correctly restore it in the future, a different approach had to be taken here, hence requiring an entire rewrite of the feature. This new approach, detailed in the following section, takes concrete learnings from the mistakes of the previous approach and thus avoids all problems mentioned above right from the start.\nDesign Projects take a classic, fully declarative approach to store their information, saving and loading a direct dump of the internal state.\nSerialization All relevant modules and data structures now have serialization and deserialization functions added, commonly prefixed with rz_serialize_ and implemented in files called serialize_*.c, as for example serialize_flag.c in the case of flags.\nFor the target data structure, SDB is being used, which is a database that is also used in other parts of rizin. What makes SDB special is its simplicity: One SDB is simply a mapping from arbitrary string keys to string values, and multiple SDBs can be nested in a tree of namespaces. This restricted design makes SDB unsuitable for many applications, but for our projects it turned out to fit very well. Inside such an SDB, when more complex structures are needed, JSON is used. This combination of well-defined formats means we can rely on them and forget about escaping or sanitizing strings in our actual serialization code.\nFor example, the same function as in the previous example would now be serialized like this:\n/core/analysis/functions 0x80485f5={\"name\":\"main\",\"bits\":32,\"type\":4,\"cc\":\"cdecl\",\"stack\":16,\"maxstack\":32,\"ninstr\":43,\"bp_frame\":true,\"bp_off\":8,\"diff\":{},\"bbs\":[134514165,134514219,134514243,134514261,134514277],\"vars\":[{\"name\":\"argv\",\"type\":\"char **\",\"kind\":\"s\",\"delta\":4,\"arg\":true,\"accs\":[{\"off\":0,\"type\":\"r\",\"sp\":4,\"reg\":\"esp\"}]},{\"name\":\"var_8h\",\"type\":\"int32_t\",\"kind\":\"b\",\"delta\":-16,\"accs\":[{\"off\":117,\"type\":\"r\",\"sp\":18446744073709551608,\"reg\":\"ebp\"}]}]} /core/analysis/blocks 0x80485f5={\"size\":54,\"jump\":134514261,\"fail\":134514219,\"traced\":true,\"ninstr\":18,\"op_pos\":[4,7,10,11,13,14,15,17,20,25,30,33,36,41,46,49,52],\"stackptr\":16,\"parent_stackptr\":0,\"cmpval\":1} 0x804862b={\"size\":24,\"jump\":134514261,\"fail\":134514243,\"traced\":true,\"ninstr\":9,\"op_pos\":[3,6,8,11,12,17,20,22],\"stackptr\":16,\"parent_stackptr\":16} 0x8048643={\"size\":18,\"jump\":134514277,\"traced\":true,\"ninstr\":5,\"op_pos\":[3,8,13,16],\"stackptr\":16,\"parent_stackptr\":16} 0x8048655={\"size\":16,\"jump\":134514277,\"traced\":true,\"ninstr\":4,\"op_pos\":[3,8,13],\"parent_stackptr\":16} 0x8048665={\"size\":15,\"traced\":true,\"ninstr\":7,\"op_pos\":[5,8,9,10,11,14],\"parent_stackptr\":0} While this certainly is harder to read for humans, it follows a clearly defined structure and all relevant information can be extracted from it directly. This kind of serialization design now also allows unit tests to be written easily and in fact all currently implemented serializations already come with such tests, aiming to ensure that all internal state is correctly saved and loaded, down to even subtle details and corner cases.\nWhat you see above is already an example of how the serialization will eventually be saved to a file. It is a simple, text-based format that stores the SDB entries line by line and takes care of any necessary escaping. While such a text-based format may not be the most efficient representation, it turned out to be more than good enough for even larger projects and in addition has certain nice properties, which we will make use of further down. However, due to the simplicity of SDB, other file formats to store the same data are theoretically feasable too.\nVersioning An important aspect is that the possibility to correctly load a project will survive even significant updates of the software. To ensure this, a simple version-based migration approach is used: The project code contains a version number defined as RZ_DB_PROJECT_VERSION, which is simply an integer that is increased every time there is a change in the format. This number is then simply saved into every project’s metadata namespace.\nLater, when loading the same project in newer rizin that also has a higher internal project version number, it will be able to know exactly the kind of format that the old project was saved with and will be able to upgrade it by successively applying migrations, which will be implemented along every increase of the project version number.\nAt the current point in time, the version number is 1 and there are no migrations. This is because at the moment, the projects feature is considered to be in a Beta phase, allowing it to be tested thoroughly and still receive changes to the format that might turn out sensible without the additional engineering overhead of implementing migrations.\nThis means that right now, everybody is highly encouraged to test projects and report any issues that might come up, but be aware of the fact that compatibility with later rizin versions may not be guaranteed and might require small manual edits in the serialized file.\nThe Beta phase will continue throughout all 0.x.y versions of rizin and end by version 1.0.0 where projects will be considered stable, meaning that all projects should always be properly loaded in all future versions and if a case is discovered where this promise is not held, it will be considered a bug and shall be fixed.\nRe-loading of underlying binaries One of the trickiest aspects of serializing a rizin session is handling the actual underlying binary that is being analyzed. In fact, speaking of “the binary” in this context is a crude underapproximation of what is actually present in Rizin.\nIgnoring debug, three modules are working together to load files: RzIO provides a generic IO layer, which can map data coming from plugins in a 64-bit address space. RzBin takes raw files from RzIO, parses their binary file formats such as ELF or PE, also using an independent plugin for each, and eventually provides information how to then lay out the contained sections in RzIO again, along with a list of symbols and other information parsed from the binary. RzCore controls how these modules are created and work together.\nThis design makes rizin’s loading mechanism very powerful and flexible, but imposes certain challenges on serialization: How to handle all the different IO plugins? Next to the one that simply loads a regular file, there are plugins for files in zip, malloc, http, shared memory, … that all need individual reconstruction logic. For regular files, how to relocate the actual file when the project is moved to another machine? From RzBin, should the symbols information also be serialized or re-parsed?\nBecause this part needs to be designed properly first and might even require some refactoring in the respective modules, its implementation has been postponed for now. But the preliminary, rough plan is the following: Every IO plugin itself provides callbacks for (de)serialization of maps created with it. All IO maps are serialized to the file using these callbacks. Information in RzBin will not be serialized but re-parsed on top of the deseralized IO maps.\nHowever, despite this full implementation being postponed, a very simple temporary solution has been implemented, which is strictly limited to the case where only a single binary is loaded from a regular file with the default loading settings, i.e. without explicitly specifying the base address for example. This makes it possible to use projects conveniently right now for the majority of use-cases. More complex cases are also already possible, as long as the loading process is done manually and the project is then loaded on top using the Poo  command, as shown in the following section.\nUsage Saving and loading projects from rizin is as simple as it can be:\n[0x00000000] P? Usage: P # Project management | Ps [] # Save a project | Po  # Open a project | Poo  # Open a project on top of currently loaded binaries Use Ps [] from a running session to save it and Po  to discard the current session and load the saved one. Alternatively, a project can also be loaded directly when starting rizin like rz -p project.rzdb.\nPo and -p will also take care of loading the single, underlying binary as explained in the previous section. If this is not desired, you can use the Poo  command to keep all current state of IO mappings and parsed binaries in place and only load the analysis information on top.\nIn Cutter, simply use the File - Save Project... menu entry or Ctrl+s shortcut to save and the Projects tab in the initial dialog to open a project:    Cutter will also ask you to save the project before quitting so no work will get lost by accident.\nFor the case explained before, where the project depends on more complex mappings than a single binary file, or if the same project should be loaded on top of another binary, the Poo  can be used. For example, this is how a project can be loaded on top of two files:\n$ rizin -- # start rizin without any file [0x00000801] on crackme.bin 0x7ff # load first file at 0x7ff [0x00000801] on kernal.bin 0xe000 # load second file at 0xe000 [0x00000801] Poo crackme.bin.rzdb # load project on top [0x00000815] pd 1 # disassemble inside the first file 0x00000815 jsr CHROUT_in_kernal ; this is a call from crackme.bin into kernal [0x00000815] pd 1 @ CHROUT_in_kernal # disassemble inside the second file ;-- CHROUT_in_kernal: 0x0000ffd2 jmp (0x0326) Version Control and Collaboration If you have used Ghidra before, you might have come across its “shared project” and Ghidra server, which are its strong, built-in features for collaborative reverse engineering with version control. Rizin takes a different approach to provide this functionality that is more in line with its UNIX-like focus. It does not implement version control itself, but instead creates project files in a way that they can work well with existing version control systems like git, which are well-tested and likely to already be familiar for users.\nBeing text files where independent content is generally split by lines, git already knows how to deal with tracking differences and merging for these files most of the time. This is for example a diff of a project where the current seek was changed and a comment added:\ndiff --git a/megabeets_0x1.rzdb b/megabeets_0x1.rzdb index 9c828f4..aed7e64 100644 --- a/megabeets_0x1.rzdb +++ b/megabeets_0x1.rzdb @@ -4,7 +4,7 @@ version=1  /core blocksize=0x100 -offset=0x8048370 +offset=0x8048600  /core/analysis @@ -158,6 +158,7 @@ watcom=cc  0x804859a=[{\"type\":\"t\",\"str\":\"char *dest\"}] 0x80485db=[{\"type\":\"t\",\"str\":\"const char *s2\"}] 0x80485e2=[{\"type\":\"t\",\"str\":\"const char *s1\"}] +0x8048600=[{\"type\":\"C\",\"str\":\"I am putting a comment here!\"}]  0x8048609=[{\"type\":\"t\",\"str\":\"const char *s\"}] 0x8048619=[{\"type\":\"t\",\"str\":\"const char *s\"}] 0x8048646=[{\"type\":\"t\",\"str\":\"const char *s\"}] Examining these json-based diffs surely is not be the most convenient way to view differences for every user, but it provides a working compromise between readability for both humans and software at the same time without requiring any programs except git up to this point. In addition, we are investigating implementing custom diff- and mergetools that could be integrated into git and are fully aware of the meaning of data in project files to present and merge differences in the best way possible while still relying on an existing version control system.\nRegarding the binary that is being analyzed in a project, if desired, it can also be put into the same git repository as the project. Since projects contain a reference to the binary file relative to the project file, it can still be re-loaded when moved to another machine.\nConclusion We hope you will enjoy using rizin with its new projects feature. If you are interested, we highly encourage you to try it out, put it through its paces, and report any potentially upcoming issues, so we will be able to iron them out until the end of the beta phase!\n","wordCount":"2739","inLanguage":"en","datePublished":"2021-01-02T00:00:00Z","dateModified":"2021-01-02T00:00:00Z","author":{"@type":"Person","name":"thestr4ng3r"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rizin.re/posts/introducing-projects/"},"publisher":{"@type":"Organization","name":"Rizin","logo":{"@type":"ImageObject","url":"https://rizin.re/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://rizin.re/ accesskey=h>Rizin</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t title="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://rizin.re/posts/><span>Blog</span></a></li><li><a href=https://rizin.re/organization/><span>Organization</span></a></li><li><a href=https://rizin.re/community/><span>Community</span></a></li><li><a href=https://rizin.re/gsoc/><span>GSoC</span></a></li><li><a href=https://cutter.re><span>Cutter</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rizin.re/>Home</a>&nbsp;»&nbsp;<a href=https://rizin.re/posts/>Posts</a></div><h1 class=post-title>Introducing Projects in Rizin</h1><div class=post-meta>January 2, 2021&nbsp;·&nbsp;13 min&nbsp;·&nbsp;thestr4ng3r</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#tldr aria-label=tl;dr>tl;dr</a></li><li><a href=#wait-werent-there-already-projects-in-radare2-before aria-label="Wait, weren&amp;rsquo;t there already projects in Radare2 before?">Wait, weren&rsquo;t there already projects in Radare2 before?</a></li><li><a href=#design aria-label=Design>Design</a><ul><li><a href=#serialization aria-label=Serialization>Serialization</a></li><li><a href=#versioning aria-label=Versioning>Versioning</a></li><li><a href=#re-loading-of-underlying-binaries aria-label="Re-loading of underlying binaries">Re-loading of underlying binaries</a></li></ul></li><li><a href=#usage aria-label=Usage>Usage</a></li><li><a href=#version-control-and-collaboration aria-label="Version Control and Collaboration">Version Control and Collaboration</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>When manually analyzing a complex binary, possibly over the course of days, weeks or even months, it is crucial to
be able to keep track of the gained knowledge through annotations such as comments, function and variable names.
As such, the tool one is working with also need to provide a reliable and future-proof way to save and restore
this information. One of the biggest additions in Rizin surely is the new projects feature, which provides
exactly this functionality in both rizin on the command line and Cutter.
In this article, we would like to give an overview of how it was designed, what exactly it promises to you,
as well as the current limitations you should be aware of when using it right now.</p><h2 id=tldr>tl;dr<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><ul><li>Projects can be used in rizin using the <code>Ps [&lt;project.rzdb>]</code> and <code>Po &lt;project.rzdb></code> commands and in Cutter through
its regular user interface.</li><li>Projects are currently in <strong>beta</strong>, including in any <code>0.x.y</code> releases of Rizin,
and will be considered <strong>stable</strong> starting with release <code>1.0.0</code>.<ul><li><strong>Beta</strong> means that all functionality is implemented and ready to use, but there is no guarantee that
the format itself will not further change slightly and thus maybe break loading a project saved right now
in a future version of Rizin.</li><li><strong>Stable</strong> means that the format is finalized and all changes inside of it will come with migrations and tests
ensuring that all projects saved before are still be loaded correctly.</li></ul></li><li>Projects may be conceptually split into two parts: the binary that is being analyzed, and
any info that has been put on top by automatic analysis or the user.<ul><li>Saving and loading of all analysis data on top of a binary, including flags, functions,
variables, types, comments is implemented.</li><li>Automatic reloading of the underlying binary is currently limited to only a single binary available as a regular file,
but this will be extended to arbitrarily complex IO mappings in the future.
However, even with the current state, it is possible to manually reconstruct more complex mappings and then load
any analysis data on top using the <code>Poo &lt;project.rzdb></code> command.</li></ul></li></ul><h2 id=wait-werent-there-already-projects-in-radare2-before>Wait, weren&rsquo;t there already projects in Radare2 before?<a hidden class=anchor aria-hidden=true href=#wait-werent-there-already-projects-in-radare2-before>#</a></h2><p>Indeed, there has been a projects feature in Radare2 since 2017. This has been removed entirely from Rizin
and is now entirely replaced by the new implementation, which has been re-designed from scratch and shares no code
with the old one.</p><p>To understand why such a radical change was necessary, let us take a closer look at how old projects were designed.
They primarily consisted of a single <code>rc</code> file, which was a radare2 script containing regular commands that would
reconstruct the session state when run. As an example, a part of such a script to load one function could look like this:</p><pre><code>&quot;f main 127 0x080485f5&quot;
&quot;af+ 0x080485f5 main s n&quot;
afb+ 0x080485f5 0x080485f5 54 0x08048655 0x0804862b
afb+ 0x080485f5 0x0804862b 24 0x08048655 0x08048643
afb+ 0x080485f5 0x08048643 18 0x08048665 0xffffffffffffffff
afb+ 0x080485f5 0x08048655 16 0x08048665 0xffffffffffffffff
afb+ 0x080485f5 0x08048665 15 0xffffffffffffffff 0xffffffffffffffff
</code></pre><p>We can see it is first creating a flag (<code>f</code>), then creating a function (<code>af+</code>)
and finally adding basic blocks to it (<code>afb+</code>).</p><p>While this general approach can work in theory, it comes with several implications:</p><ul><li>Commands can have side effects. As an example, until only very recently, the <code>afb+</code> command would trigger a heavy function
analysis loop after adding a basic block in some circumstances, creating variables, X-Refs and other information.
The information coming out of this side effect would then mix with the rest of the restored session, resulting for example
in unwanted variables being present after loading.</li><li>Commands and their semantics can change over time. Simple changes include command name changes or the order of arguments,
more complex ones may involve major restructuring of underlying concepts, thus requiring entirely different command sequences
to achieve the same results.
Of course, since the saving instance can not predict the future, it would be solely the responsibility of loading
instance to account for such changes.
However with the project being an unstructured sequence of commands that may not even be part of the codebase anymore
at this point, performing such a migration is far from trivial and highly error-prone.</li></ul><p>Moreover, before rizin&rsquo;s new command parser was created, there was no formal specification of the command syntax.
You can see in the above example that the first <code>af+</code> command is enclosed in <code>"..."</code>, which is to account
for cases such as the function name being <code>ma;in</code> where otherwise the <code>;</code> would be interpreted as a separator for a new
command, similar as in an SQL injection, eventually resulting in broken project loading.
However, this quoting scheme still fails for names such as <code>ma"in</code>.
As mentioned, this could have been eventually fixed using the new command parser, which has a well-defined escaping syntax,
but it still has been the source of many bugs in the past.</p><p>On top of all these fundamental issues comes the fact that these projects were never tested apart from very few
integration tests covering only a tiny fraction of the information potentially included in a session.
All these aspects combined led to a high density of bugs and uncertainty when working with this feature.
If you were very lucky, the project would save and load as expected. If you were less lucky, the loading
would simply result in an error. But, and this has been the most likely case, if you were unlucky,
the project would load seemingly correctly, but you would notice only later that the loaded data was deeply corrupted.</p><p>Despite some of these issues being theoretically possible to fix, the conceptual problems of using commands
for projects remain. Because the ability to save a session is only even remotely useful when it can also be relied
upon to always correctly restore it in the future, a different approach had to be taken here,
hence requiring an entire rewrite of the feature.
This new approach, detailed in the following section, takes concrete learnings from the mistakes of the previous approach
and thus avoids all problems mentioned above right from the start.</p><h2 id=design>Design<a hidden class=anchor aria-hidden=true href=#design>#</a></h2><p>Projects take a classic, fully declarative approach to store their information, saving and loading a direct dump of
the internal state.</p><h3 id=serialization>Serialization<a hidden class=anchor aria-hidden=true href=#serialization>#</a></h3><p>All relevant modules and data structures now have serialization and deserialization functions added, commonly prefixed
with <code>rz_serialize_</code> and implemented in files called <code>serialize_*.c</code>, as for example
<a href=https://github.com/rizinorg/rizin/blob/adc5fb8a08e88732939e4fb7643b90af195c797e/librz/flag/serialize_flag.c><code>serialize_flag.c</code></a>
in the case of flags.</p><p>For the target data structure, SDB is being used, which is a database that is also used in other parts of rizin.
What makes SDB special is its simplicity: One SDB is simply a mapping from arbitrary string keys to string values, and
multiple SDBs can be nested in a tree of namespaces.
This restricted design makes SDB unsuitable for many applications, but for our projects it turned out to fit very well.
Inside such an SDB, when more complex structures are needed, JSON is used.
This combination of well-defined formats means we can rely on them and forget about escaping or sanitizing strings in our
actual serialization code.</p><p>For example, the same function as in the previous example would now be serialized like this:</p><pre><code>/core/analysis/functions
0x80485f5={&quot;name&quot;:&quot;main&quot;,&quot;bits&quot;:32,&quot;type&quot;:4,&quot;cc&quot;:&quot;cdecl&quot;,&quot;stack&quot;:16,&quot;maxstack&quot;:32,&quot;ninstr&quot;:43,&quot;bp_frame&quot;:true,&quot;bp_off&quot;:8,&quot;diff&quot;:{},&quot;bbs&quot;:[134514165,134514219,134514243,134514261,134514277],&quot;vars&quot;:[{&quot;name&quot;:&quot;argv&quot;,&quot;type&quot;:&quot;char **&quot;,&quot;kind&quot;:&quot;s&quot;,&quot;delta&quot;:4,&quot;arg&quot;:true,&quot;accs&quot;:[{&quot;off&quot;:0,&quot;type&quot;:&quot;r&quot;,&quot;sp&quot;:4,&quot;reg&quot;:&quot;esp&quot;}]},{&quot;name&quot;:&quot;var_8h&quot;,&quot;type&quot;:&quot;int32_t&quot;,&quot;kind&quot;:&quot;b&quot;,&quot;delta&quot;:-16,&quot;accs&quot;:[{&quot;off&quot;:117,&quot;type&quot;:&quot;r&quot;,&quot;sp&quot;:18446744073709551608,&quot;reg&quot;:&quot;ebp&quot;}]}]}

/core/analysis/blocks
0x80485f5={&quot;size&quot;:54,&quot;jump&quot;:134514261,&quot;fail&quot;:134514219,&quot;traced&quot;:true,&quot;ninstr&quot;:18,&quot;op_pos&quot;:[4,7,10,11,13,14,15,17,20,25,30,33,36,41,46,49,52],&quot;stackptr&quot;:16,&quot;parent_stackptr&quot;:0,&quot;cmpval&quot;:1}
0x804862b={&quot;size&quot;:24,&quot;jump&quot;:134514261,&quot;fail&quot;:134514243,&quot;traced&quot;:true,&quot;ninstr&quot;:9,&quot;op_pos&quot;:[3,6,8,11,12,17,20,22],&quot;stackptr&quot;:16,&quot;parent_stackptr&quot;:16}
0x8048643={&quot;size&quot;:18,&quot;jump&quot;:134514277,&quot;traced&quot;:true,&quot;ninstr&quot;:5,&quot;op_pos&quot;:[3,8,13,16],&quot;stackptr&quot;:16,&quot;parent_stackptr&quot;:16}
0x8048655={&quot;size&quot;:16,&quot;jump&quot;:134514277,&quot;traced&quot;:true,&quot;ninstr&quot;:4,&quot;op_pos&quot;:[3,8,13],&quot;parent_stackptr&quot;:16}
0x8048665={&quot;size&quot;:15,&quot;traced&quot;:true,&quot;ninstr&quot;:7,&quot;op_pos&quot;:[5,8,9,10,11,14],&quot;parent_stackptr&quot;:0}
</code></pre><p>While this certainly is harder to read for humans, it follows a clearly defined structure and all relevant information
can be extracted from it directly.
This kind of serialization design now also allows unit tests to be written easily and in fact all currently implemented
serializations already come with such tests, aiming to ensure that all internal state is correctly saved and loaded,
down to even subtle details and corner cases.</p><p>What you see above is already an example of how the serialization will eventually be saved to a file.
It is a simple, text-based format that stores the SDB entries line by line and takes care of any necessary escaping.
While such a text-based format may not be the most efficient representation, it turned out to be more than good enough
for even larger projects and in addition has certain nice properties, which we will make use of further down.
However, due to the simplicity of SDB, other file formats to store the same data are theoretically feasable too.</p><h3 id=versioning>Versioning<a hidden class=anchor aria-hidden=true href=#versioning>#</a></h3><p>An important aspect is that the possibility to correctly load a project will survive even significant updates of the software.
To ensure this, a simple version-based migration approach is used: The project code contains a version number defined as
<a href=https://github.com/rizinorg/rizin/blob/adc5fb8a08e88732939e4fb7643b90af195c797e/librz/core/project.c#L10><code>RZ_DB_PROJECT_VERSION</code></a>,
which is simply an integer that is increased every time there is a change in the format.
This number is then simply saved into every project&rsquo;s metadata namespace.</p><p>Later, when loading the same project in newer rizin that also has a higher internal project version number,
it will be able to know exactly the kind of format that the old project was saved with and will be able to upgrade it by
successively applying migrations, which will be implemented along every increase of the project version number.</p><p>At the current point in time, the version number is <code>1</code> and there are no migrations. This is because at the moment,
the projects feature is considered to be in a <strong>Beta</strong> phase, allowing it to be tested thoroughly and still
receive changes to the format that might turn out sensible without the additional engineering overhead of implementing
migrations.</p><p>This means that right now, everybody is highly encouraged to test projects and report any issues that might come up,
but be aware of the fact that compatibility with later rizin versions may not be guaranteed and might require
small manual edits in the serialized file.</p><p>The <strong>Beta</strong> phase will continue throughout all <code>0.x.y</code> versions of rizin and end by version <code>1.0.0</code> where
projects will be considered <strong>stable</strong>, meaning that all projects should always be properly loaded in all future versions
and if a case is discovered where this promise is not held, it will be considered a bug and shall be fixed.</p><h3 id=re-loading-of-underlying-binaries>Re-loading of underlying binaries<a hidden class=anchor aria-hidden=true href=#re-loading-of-underlying-binaries>#</a></h3><p>One of the trickiest aspects of serializing a rizin session is handling the actual underlying binary that is being
analyzed. In fact, speaking of &ldquo;the binary&rdquo; in this context is a crude underapproximation of what is actually present
in Rizin.</p><p>Ignoring debug, three modules are working together to load files: <code>RzIO</code> provides a
generic IO layer, which can map data coming from plugins in a 64-bit address space.
<code>RzBin</code> takes raw files from <code>RzIO</code>, parses their binary file formats such as ELF or PE,
also using an independent plugin for each, and eventually provides information how to then
lay out the contained sections in <code>RzIO</code> again, along with a list of symbols and other information parsed from the binary.
<code>RzCore</code> controls how these modules are created and work together.</p><p>This design makes rizin&rsquo;s loading mechanism very powerful and flexible, but imposes certain challenges on serialization:
How to handle all the different IO plugins? Next to the one that simply loads a regular file, there are plugins for
files in zip, malloc, http, shared memory, &mldr; that all need individual reconstruction logic.
For regular files, how to relocate the actual file when the project is moved to another machine?
From <code>RzBin</code>, should the symbols information also be serialized or re-parsed?</p><p>Because this part needs to be designed properly first and might even require some refactoring in the respective
modules, its implementation has been postponed for now.
But the preliminary, rough plan is the following:
Every IO plugin itself provides callbacks for (de)serialization of maps created with it.
All IO maps are serialized to the file using these callbacks.
Information in <code>RzBin</code> will not be serialized but re-parsed on top of the deseralized IO maps.</p><p>However, despite this full implementation being postponed, a very simple temporary solution has been implemented,
which is strictly limited to the case where only <strong>a single binary</strong> is loaded from a <strong>regular file</strong>
with the <strong>default loading settings</strong>, i.e. without explicitly specifying the base address for example.
This makes it possible to use projects conveniently right now for the majority of use-cases.
More complex cases are also already possible, as long as the loading process is done manually and the project
is then loaded on top using the <code>Poo &lt;file.rzdb></code> command, as shown in the following section.</p><h2 id=usage>Usage<a hidden class=anchor aria-hidden=true href=#usage>#</a></h2><p>Saving and loading projects from rizin is as simple as it can be:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#f92672>[</span>0x00000000<span style=color:#f92672>]</span>&gt; P?
Usage: P&lt;so?&gt;   <span style=color:#75715e># Project management</span>
| Ps <span style=color:#f92672>[</span>&lt;project.rzdb&gt;<span style=color:#f92672>]</span> <span style=color:#75715e># Save a project</span>
| Po &lt;project.rzdb&gt;   <span style=color:#75715e># Open a project</span>
| Poo &lt;project.rzdb&gt;  <span style=color:#75715e># Open a project on top of currently loaded binaries</span>
</code></pre></div><p>Use <code>Ps [&lt;project.rzdb>]</code> from a running session to save it and <code>Po &lt;project.rzdb></code> to discard the current
session and load the saved one.
Alternatively, a project can also be loaded directly when starting rizin like <code>rz -p project.rzdb</code>.</p><p><code>Po</code> and <code>-p</code> will also take care of loading the single, underlying binary as explained in the previous section.
If this is not desired, you can use the <code>Poo &lt;project.rzdb></code> command to keep all current state of IO mappings and
parsed binaries in place and only load the analysis information on top.</p><p>In Cutter, simply use the <code>File -> Save Project...</code> menu entry or <code>Ctrl+s</code> shortcut to save
and the <code>Projects</code> tab in the initial dialog to open a project:<div style="display:flex;justify-content:space-evenly;align-items:center;flex-flow:row nowrap"><div style=margin:8px><img src=cutter-project-menu.png></div><div style=margin:8px><img src=cutter-project-dialog.png></div></div>Cutter will also ask you to save the project before quitting so no work will get lost by accident.</p><p>For the case explained before, where the project depends on more complex mappings than a single binary file,
or if the same project should be loaded on top of another binary, the <code>Poo &lt;project.rzdb></code> can be used.
For example, this is how a project can be loaded on top of two files:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ rizin --                            <span style=color:#75715e># start rizin without any file</span>
<span style=color:#f92672>[</span>0x00000801<span style=color:#f92672>]</span>&gt; on crackme.bin 0x7ff    <span style=color:#75715e># load first file at 0x7ff</span>
<span style=color:#f92672>[</span>0x00000801<span style=color:#f92672>]</span>&gt; on kernal.bin 0xe000    <span style=color:#75715e># load second file at 0xe000</span>
<span style=color:#f92672>[</span>0x00000801<span style=color:#f92672>]</span>&gt; Poo crackme.bin.rzdb    <span style=color:#75715e># load project on top</span>
<span style=color:#f92672>[</span>0x00000815<span style=color:#f92672>]</span>&gt; pd <span style=color:#ae81ff>1</span>                    <span style=color:#75715e># disassemble inside the first file</span>
            0x00000815      jsr CHROUT_in_kernal ; this is a call from crackme.bin into kernal
<span style=color:#f92672>[</span>0x00000815<span style=color:#f92672>]</span>&gt; pd <span style=color:#ae81ff>1</span> @ CHROUT_in_kernal <span style=color:#75715e># disassemble inside the second file</span>
            ;-- CHROUT_in_kernal:
            0x0000ffd2      jmp <span style=color:#f92672>(</span>0x0326<span style=color:#f92672>)</span>
</code></pre></div><h2 id=version-control-and-collaboration>Version Control and Collaboration<a hidden class=anchor aria-hidden=true href=#version-control-and-collaboration>#</a></h2><p>If you have used Ghidra before, you might have come across its &ldquo;shared project&rdquo; and Ghidra server, which
are its strong, built-in features for collaborative reverse engineering with version control.
Rizin takes a different approach to provide this functionality that is more in line with its UNIX-like focus.
It does not implement version control itself, but instead creates project files in a way that they
can work well with existing version control systems like git, which are well-tested
and likely to already be familiar for users.</p><p>Being text files where independent content is generally split by lines, git already knows how to deal with
tracking differences and merging for these files most of the time.
This is for example a diff of a project where the current seek was changed and a comment added:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff>diff --git a/megabeets_0x1.rzdb b/megabeets_0x1.rzdb
index 9c828f4..aed7e64 100644
<span style=color:#f92672>--- a/megabeets_0x1.rzdb
</span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/megabeets_0x1.rzdb
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -4,7 +4,7 @@ version=1
</span><span style=color:#75715e></span> 
 /core
 blocksize=0x100
<span style=color:#f92672>-offset=0x8048370
</span><span style=color:#f92672></span><span style=color:#a6e22e>+offset=0x8048600
</span><span style=color:#a6e22e></span> 
 /core/analysis
 
<span style=color:#75715e>@@ -158,6 +158,7 @@ watcom=cc
</span><span style=color:#75715e></span> 0x804859a=[{&#34;type&#34;:&#34;t&#34;,&#34;str&#34;:&#34;char *dest&#34;}]
 0x80485db=[{&#34;type&#34;:&#34;t&#34;,&#34;str&#34;:&#34;const char *s2&#34;}]
 0x80485e2=[{&#34;type&#34;:&#34;t&#34;,&#34;str&#34;:&#34;const char *s1&#34;}]
<span style=color:#a6e22e>+0x8048600=[{&#34;type&#34;:&#34;C&#34;,&#34;str&#34;:&#34;I am putting a comment here!&#34;}]
</span><span style=color:#a6e22e></span> 0x8048609=[{&#34;type&#34;:&#34;t&#34;,&#34;str&#34;:&#34;const char *s&#34;}]
 0x8048619=[{&#34;type&#34;:&#34;t&#34;,&#34;str&#34;:&#34;const char *s&#34;}]
 0x8048646=[{&#34;type&#34;:&#34;t&#34;,&#34;str&#34;:&#34;const char *s&#34;}]
</code></pre></div><p>Examining these json-based diffs surely is not be the most convenient way to view differences for every user, but
it provides a working compromise between readability for both humans and software at the same time without
requiring any programs except git up to this point.
In addition, we are investigating implementing custom diff- and mergetools that could be integrated into git and are
fully aware of the meaning of data in project files to present and merge differences in the best way possible while
still relying on an existing version control system.</p><p>Regarding the binary that is being analyzed in a project, if desired, it can also be put into the same git repository
as the project. Since projects contain a reference to the binary file relative to the project file, it can still be
re-loaded when moved to another machine.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>We hope you will enjoy using rizin with its new projects feature. If you are interested, we highly encourage you
to try it out, put it through its paces, and <a href=https://github.com/rizinorg/rizin/issues>report</a> any
potentially upcoming issues, so we will be able to iron them out until the end of the beta phase!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://rizin.re/tags/rizin/>rizin</a></li><li><a href=https://rizin.re/tags/projects/>projects</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Introducing Projects in Rizin on twitter" href="https://twitter.com/intent/tweet/?text=Introducing%20Projects%20in%20Rizin&url=https%3a%2f%2frizin.re%2fposts%2fintroducing-projects%2f&hashtags=rizin%2cprojects"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Introducing Projects in Rizin on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2frizin.re%2fposts%2fintroducing-projects%2f&title=Introducing%20Projects%20in%20Rizin&summary=Introducing%20Projects%20in%20Rizin&source=https%3a%2f%2frizin.re%2fposts%2fintroducing-projects%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Introducing Projects in Rizin on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frizin.re%2fposts%2fintroducing-projects%2f&title=Introducing%20Projects%20in%20Rizin"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Introducing Projects in Rizin on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frizin.re%2fposts%2fintroducing-projects%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Introducing Projects in Rizin on whatsapp" href="https://api.whatsapp.com/send?text=Introducing%20Projects%20in%20Rizin%20-%20https%3a%2f%2frizin.re%2fposts%2fintroducing-projects%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Introducing Projects in Rizin on telegram" href="https://telegram.me/share/url?text=Introducing%20Projects%20in%20Rizin&url=https%3a%2f%2frizin.re%2fposts%2fintroducing-projects%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://rizin.re/>Rizin</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>