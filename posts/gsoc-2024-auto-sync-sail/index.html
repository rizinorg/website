<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GSoC 2024 - RISC-V Capstone auto-sync and RzIL uplifting | Rizin</title><meta name=keywords content="rizin,capstone,gsoc,rzil"><meta name=description content="A description of the original GSoC 2024 task plans of updating RISC-V disassembler in Capstone, updating it in Rizin, and implementing RzIL uplifting and the actual progress"><meta name=author content="Mostafa"><link rel=canonical href=https://rizin.re/posts/gsoc-2024-auto-sync-sail/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://rizin.re/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rizin.re/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rizin.re/favicon-32x32.png><link rel=apple-touch-icon href=https://rizin.re/apple-touch-icon.png><link rel=mask-icon href=https://rizin.re/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link href=https://cdn.lineicons.com/2.0/LineIcons.css rel=stylesheet><link rel=stylesheet href=https://rizin.re/css/custom/rizin.min.f00018437c0f0fe081c2a5ccdb294666c6f0adc5f7ca5ce6f622496f40fc88ac.css><meta property="og:title" content="GSoC 2024 - RISC-V Capstone auto-sync and RzIL uplifting"><meta property="og:description" content="A description of the original GSoC 2024 task plans of updating RISC-V disassembler in Capstone, updating it in Rizin, and implementing RzIL uplifting and the actual progress"><meta property="og:type" content="article"><meta property="og:url" content="https://rizin.re/posts/gsoc-2024-auto-sync-sail/"><meta property="og:image" content="https://rizin.re/images/rizin_preview.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-23T00:00:00+00:00"><meta property="article:modified_time" content="2024-12-23T00:00:00+00:00"><meta property="og:site_name" content="Rizin"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rizin.re/images/rizin_preview.png"><meta name=twitter:title content="GSoC 2024 - RISC-V Capstone auto-sync and RzIL uplifting"><meta name=twitter:description content="A description of the original GSoC 2024 task plans of updating RISC-V disassembler in Capstone, updating it in Rizin, and implementing RzIL uplifting and the actual progress"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rizin.re/posts/"},{"@type":"ListItem","position":2,"name":"GSoC 2024 - RISC-V Capstone auto-sync and RzIL uplifting","item":"https://rizin.re/posts/gsoc-2024-auto-sync-sail/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GSoC 2024 - RISC-V Capstone auto-sync and RzIL uplifting","name":"GSoC 2024 - RISC-V Capstone auto-sync and RzIL uplifting","description":"A description of the original GSoC 2024 task plans of updating RISC-V disassembler in Capstone, updating it in Rizin, and implementing RzIL uplifting and the actual progress","keywords":["rizin","capstone","gsoc","rzil"],"articleBody":"Hello, I’m Mostafa. I graduated with Excellence from Cairo University’s Faculty of Engineering, Computer Engineering Department, class of 2023. I write C++ for a living. I love systems programming, metaprogramming \u0026 DSLs, as well as Compilers \u0026 VMs. You can find me @Github, and @Linkedin.\nI was honored to participate again as a contributor in the 2024 GSoC with the Rizin Organization. The original project was implementing binary lifting techniques for RISC-V instructions onto Rizin’s custom internal representation, called RzIL. However, updating the RISC-V Capstone disassembler (originally a small task in the project preamble) turned out to need much more work than expected, and blocked the rest of the project.\nLet’s start at the beginning.\nRISC-V… Lifting? Lifting is a term of art in compiler research and implementation, it refers to any process that takes as input a low-level machine code program and outputs a higher-level program. The reverse process, lowering, is what compilers do when they compile from a relatively high level language like C or LLVM IR to machine code. So you could simply think of lifting as a synonym for “Decompiling” or “Reverse-Compiling”.\nIn the context of Rizin, lifting refers to transforming a machine code program written for any of the hardware architectures that Rizin understands (x86, RISC-V, 6502, etc…) to a Rizin-specific intermediate language called RzIL.\nBy doing this, Rizin’s developers can write generic analysis algorithms that interpret RzIL instructions, and a generic VM that executes them, only once. Then, for each architecture that Rizin supports, a lifter that transforms machine code written for that architecture into RzIL is written, and as a result we get all the analysis algorithms and VM execution capabilities “for free”.\nIn a nutshell, RzIL is the universal “Lingua Franca” for Rizin, like English is for Software Engineering.\nFigure 1: Without RzIL, there is no smarter way to perform N operations for M assembly languages other than doing an NxM amount of work, implementing the N operations over and over again per each language/architecture.\nFigure 2: With RzIL, the amount of work to support N operations for M architectures is N+M, the N operations are written exactly once for the intermediate language, then M transformers are written to lift each of the M architectures to the intermediate language.\nFor want of a disassembler So the original plan was to write the grey arrow in the figure above: a lifter from RISC-V machine code into RzIL. However, the first step in doing that is to “parse” RISC-V instructions from their binary form into a convenient data structure. We call that “parsing” step disassembly, or, more accurately, decoding.\nSide Note: lots of people, when “disassembly” and “assembly” are mentioned, will probably think of the following diagram:\nThis is not wrong for most purposes. However, in the context of this writeup it’s better to have the following and more detailed picture in mind:\nIn this writeup I’m more interested in the left-to-right flow: decoding from a binary to a structured (e.g. C struct) representation of the instruction, then assembling the structured representation of the instruction into a string form. Confusingly, sometimes “Disassembly” is used to include both Disassembly and Decoding, for example in Capstone the structured representation includes as a member its own toString serialization. It will often be clear from context what step is meant, and decoding is often far more important than disassembly.\nWhere were we? Ah yes, we were supposed to “parse” (i.e. decode) an instruction from its binary form into a convenient data structure, so that we can write elegant code that easily and robustly lifts it into RzIL.\nThe good news is that Rizin already has a RISC-V decoder/disassembler, since it uses as a library the project Capstone, which is a general-purpose disassembler framework for multiple architectures, including RISC-V.\nThe bad news? The RISC-V disassembler was incomplete and out of date.\nYou won’t catch it missing a variant of an ADD or a SUB, not even MULs or DIVs, but you can catch it missing the zba, clz, or xnor instructions, for example. Those, respectively, accelerate array indexing, count leading zeros, and perform an exclusive NOR. Capstone’s current RISC-V disassembler includes none of those instructions. We could argue whether those instructions are really “Useful” or “Common” in real software: but at the end of the day they’re part of RISC-V, and any compliant RISC-V tool must be aware of them. Capstone sometimes also chokes on quite basic instructions, like LOAD.\nRISC-V has a somewhat unusual approach to ISA evolution: it embraces extensions openly in its standard. Most architectures define new “versions” or “editions” whenever they change, RISC-V instead defines self-contained “modules” of behaviour and ISA state, even opening the door to vendors (companies selling SoCs and other products with RISC-V cores) to make their own vedor-defined extensions that co-exist with the rest of the architecture and its standard extensions. Each extension as well as the base architecture could evolve through different versions indepedently from other extensions. The RISC-V architecture is thus more of a family of architectures specified together rather than a single one.\nCapstone was originally written based on codegen logic from LLVM. It’s essentially a port of LLVM disassembly logic from C++ to C (along with much simplification and cleaning up). Unfortunately, LLVM keeps updating that logic to reflect the fast-moving development and evolution of the architectures; those updates are not magically reflected back into Capstone! To make matters even worse, even LLVM proper can’t completely keep up with all the updates that happen to all the architectures it supports, it lags.\nThe Capstone project maintains an update tool called Auto-Sync, which can semi-automatically synchronize changes from LLVM to Capstone (using Tree-sitter magic). Alas, it can only do that for some architectures, and RISC-V is not among the supported ones. Also, we already saw how even LLVM is not completely on top of all updates. Fortunately, the solution exists, just hiding elswhere.\nTo Sail the high seas and RISC it all The problem of describing Instruction Set Architectures (ISAs) accurately so that we can do plenty of useful things to them (assembly, disassembly, emulation, codegen, etc…) faces many projects and researchers, so much so that some smart people have developed an entirely new special language for it, Sail. Sail is a language designed specifically to address the problem of describing all aspects of ISAs: how the instructions are encoded into binary, how they execute, etc…\nNow, if only there was a project that used Sail to describe RISC-V… wait, there is! It’s called Sail-RISCV. It’s such a complete and up-to-date description of RISC-V that the RISC-V foundation adopted it as the official source of truth for the architecture, this means that however the Sail code behaves, is - by definition - how RISC-V should behave.\nOther architectures modelled in Sail are several versions of ARM, a considerable part of x86, and a research version of MIPS called CHERI-MIPS, which includes hardware extensions to assist and accelerate memory safe pointers. The ARM and x86 models are auto-generated from other descriptions, and all 3 models are much less active than RISC-V’s.\nLet’s see a snippet of what Sail looks like in practice, here’s the definition of RISC-V IType (immediate) instructions:\nThe rule might be as cryptic as latin if you’re not used to pattern-matching constructs from functional languages, but what it’s saying is simply the following:\nIf the first (least-significant) 7 bits of the 32-bit instruction are: 0010011 And if the 3 bits from bit 12 to bit 14 are in the table encdec_iop Then, the operation specified by this instruction is whatever enum corresponding to bits 12:14 in the encdec_iop table, and the args are: The 5-bit register index rd in bits 7 through 11 The 5-bit register index rs1 in bits 15 through 19 The 12-bit literal imm in bits 20 through 31 Otherwise, if (1) and (2) are not true, keep checking the 32-bit binary instruction against other rules In case you’re wondering what regidx is, it’s an alias for the type of 5-bit integers (or, as Sail calls them, bitvectors). Sail-RISCV uses it to refer to registers everywhere because register files in RISC-V always have 32 registers.\nIn case you’re wondering about the double arrow, that’s because this rule is a clause in a “Mapping”, a Sail innovation that basically means a bidirectional function: it can be used to decode binary instructions into structured objects, and to encode structured objects into binary instructions (that’s why it’s called encdec!).\nSail-RISCV contains ~280-290 rules of this form, and hundreds of other rules, sub-rules, and varied logic describing how RISC-V instructions are assembled, executed, how memory is accessed, how privliege levels and syscalls work, and so on.\nWe want this information, and we want it in C. We could port it by hand into C (good luck finishing in 2/3 years :(), or… we can use trusty code generation.\nRISC-V Auto-Sync So this is what my GSoC project this year was all about:\nUse Sail’s compiler (written in OCaml) as a library to load, parse, and typecheck Sail-RISCV Process the AST of Sail-RISCV and generate data structures representing the important logic Generate C code from those data structures That is, the code I wrote transformed the rule above into the following C code:\n// ---------------------------ITYPE------------------------------- { if (((binary_stream \u0026 0x000000000000007F) == 0x13)) { uint64_t op = 0xFFFFFFFFFFFFFFFF; switch ((binary_stream \u0026 0x0000000000007000) \u003e\u003e 12) { case 0x7: op = RISCV_ANDI; break; case 0x3: op = RISCV_SLTIU; break; case 0x2: op = RISCV_SLTI; break; case 0x6: op = RISCV_ORI; break; case 0x4: op = RISCV_XORI; break; case 0x0: op = RISCV_ADDI; break; } if (op != 0xFFFFFFFFFFFFFFFF) { uint64_t rd = (binary_stream \u0026 0x0000000000000F80) \u003e\u003e 7; uint64_t rs1 = (binary_stream \u0026 0x00000000000F8000) \u003e\u003e 15; uint64_t imm = (binary_stream \u0026 0x00000000FFF00000) \u003e\u003e 20; tree-\u003east_node_type = RISCV_ITYPE; tree-\u003east_node.itype.imm = imm; tree-\u003east_node.itype.rs1 = rs1; tree-\u003east_node.itype.rd = rd; tree-\u003east_node.itype.op = op; return; } } } //------------------------------------------------------------ This low-level soup of shifts and masks performs the exact logic described in the Sail snippet earlier, just in C. It continues on like that for 9K lines of generated code (#includeing approximately 2K lines of generated AST definition).\nIn addition to this, the logic that disassembles the decoded structured objects into strings is also translated. Overall, the generated code is about 20K of C, but it’s still not finished yet.\nLoose Ends The 20K of generated C code is still not merged into Capstone. Before merging, it must first incorporate additional logic into the generated decode functions, it must also infer the type of each operand (whether it’s a register, a memory address, or a literal. If it’s a register, is it floating point or integer, etc…). Those details can easily consume another writeup, but they’re all managable.\nThe generator itself is ~2500 lines of idiomatic (I hope) OCaml. But since Sail is a complex language, the tool must make some assumptions about the input that might not survive the evolution of Sail-RISCV, the application to other Sail models, or the active evolution of Sail itself.\nFinally, we haven’t addressed the original problem yet! I hope to eventually and finally write the grey arrow in the first diagram: Lifting RISC-V instructions to RzIL code.\nConclusion Let’s summarize this rollercoaster journey:\nWe just wanted to write a binary lifter for RISC-V instructions into RzIL, Rizin’s intermediate language. But in order to do that, we first have to have an up-to-date RISC-V decoder/disassembler. Rizin depends on Capstone for RISC-V disassembly, but Capstone RISC-V disassembly logic is ported from old LLVM logic that is not up-to-date. Even modern LLVM is not completely up-to-date with RISC-V. But Sail-RISCV is, and it’s adopted by the RISC-V foundation as the most authoritative model of the RISC-V architecture. And thus, we can generate a Capstone disassembler module from Sail-RISCV, by depending on the Sail compiler as a library. It was fun. Frustrating and long-winded at times, but what kind of programming isn’t? That’s part of the thrill anyway!\nThat’s all and Happy Holidays! Keep coding through the wind and the snow.\n","wordCount":"2007","inLanguage":"en","datePublished":"2024-12-23T00:00:00Z","dateModified":"2024-12-23T00:00:00Z","author":{"@type":"Person","name":"Mostafa"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rizin.re/posts/gsoc-2024-auto-sync-sail/"},"publisher":{"@type":"Organization","name":"Rizin","logo":{"@type":"ImageObject","url":"https://rizin.re/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>.theme-toggle{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://rizin.re/ accesskey=h>Rizin</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t title="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://rizin.re/posts/ target><span>Blog</span></a></li><li><a href=https://rizin.re/organization/ target><span>Organization</span></a></li><li><a href=https://rizin.re/community/ target><span>Community</span></a></li><li><a href=https://rizin.re/gsoc/ target><span>GSoC</span></a></li><li><a href=https://rizin.re/roadmap/ target><span>Roadmap</span></a></li><li><a href=https://cutter.re target=_blank><span>Cutter</span></a></li><li><a href=https://github.com/rizinorg/rizin target=_blank><i class="lni lni-github-original"></i>
<span>Source</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rizin.re/>Home</a>&nbsp;»&nbsp;<a href=https://rizin.re/posts/>Posts</a></div><h1 class=post-title>GSoC 2024 - RISC-V Capstone auto-sync and RzIL uplifting</h1><div class=post-meta><span title='2024-12-23 00:00:00 +0000 UTC'>December 23, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Mostafa</div></header><div class=post-content><p>Hello, I’m Mostafa. I graduated with Excellence from Cairo University’s Faculty of Engineering, Computer Engineering Department, class of 2023. I write C++ for a living. I love systems programming, metaprogramming & DSLs, as well as Compilers & VMs. You can find me @<a href=https://github.com/moste00>Github</a>, and @<a href=www.linkedin.com/in/mostafa-m-kamal-b015691b1>Linkedin</a>.</p><p>I was honored to participate again as a contributor in the 2024 GSoC with the Rizin Organization. The original project was implementing binary lifting techniques for RISC-V instructions onto Rizin&rsquo;s custom internal representation, called RzIL. However, updating the RISC-V Capstone disassembler (originally a small task in the project preamble) turned out to need much more work than expected, and blocked the rest of the project.</p><p>Let&rsquo;s start at the beginning.</p><h1 id=risc-v-lifting>RISC-V… Lifting?<a hidden class=anchor aria-hidden=true href=#risc-v-lifting>#</a></h1><p><em><strong>Lifting</strong></em> is a term of art in compiler research and implementation, it refers to any process that takes as input a low-level machine code program and outputs a higher-level program. The reverse process, <em><strong>lowering</strong></em>, is what compilers do when they compile from a relatively high level language like C or LLVM IR to machine code. So you could simply think of lifting as a synonym for “Decompiling” or “Reverse-Compiling”.</p><p>In the context of Rizin, lifting refers to transforming a machine code program written for any of the hardware architectures that Rizin understands (x86, RISC-V, 6502, etc&mldr;) to a Rizin-specific intermediate language called RzIL.</p><p>By doing this, Rizin’s developers can write generic analysis algorithms that interpret RzIL instructions, and a generic VM that executes them, only once. Then, for each architecture that Rizin supports, a lifter that transforms machine code written for that architecture into RzIL is written, and as a result we get all the analysis algorithms and VM execution capabilities “for free”.</p><p>In a nutshell, RzIL is the universal “Lingua Franca” for Rizin, like English is for Software Engineering.</p><p><img loading=lazy src=world-without-rzil.png alt></p><p>Figure 1: Without RzIL, there is no smarter way to perform N operations for M assembly languages other than doing an NxM amount of work, implementing the N operations over and over again per each language/architecture.</p><p><img loading=lazy src=world-with-rzil.png alt></p><p>Figure 2: With RzIL, the amount of work to support N operations for M architectures is N+M, the N operations are written exactly once for the intermediate language, then M transformers are written to lift each of the M architectures to the intermediate language.</p><h1 id=for-want-of-a-disassembler>For want of a disassembler<a hidden class=anchor aria-hidden=true href=#for-want-of-a-disassembler>#</a></h1><p>So the original plan was to write the grey arrow in the figure above: a lifter from RISC-V machine code into RzIL. However, the first step in doing that is to “parse” RISC-V instructions from their binary form into a convenient data structure. We call that “parsing” step disassembly, or, more accurately, decoding.</p><blockquote><blockquote><p>Side Note: lots of people, when “disassembly” and “assembly” are mentioned, will probably think of the following diagram:</p></blockquote></blockquote><p><img loading=lazy src=asm-disasm.png alt></p><p>This is not wrong for most purposes. However, in the context of this writeup it’s better to have the following and more detailed picture in mind:</p><p><img loading=lazy src=asm-disasm-enc-dec.png alt></p><p>In this writeup I’m more interested in the left-to-right flow: decoding from a binary to a structured (e.g. C struct) representation of the instruction, then assembling the structured representation of the instruction into a string form. Confusingly, sometimes “Disassembly” is used to include both Disassembly <strong>and</strong> Decoding, for example in Capstone the structured representation includes as a member its own <code>toString</code> serialization. It will often be clear from context what step is meant, and decoding is often far more important than disassembly.</p><p>Where were we? Ah yes, we were supposed to “parse” (i.e. decode) an instruction from its binary form into a convenient data structure, so that we can write elegant code that easily and robustly lifts it into RzIL.</p><p>The good news is that Rizin already has a RISC-V decoder/disassembler, since it uses as a library the project <em>Capstone</em>, which is a general-purpose disassembler framework for multiple architectures, including RISC-V.</p><p>The bad news? The RISC-V disassembler was incomplete and out of date.</p><p>You won&rsquo;t catch it missing a variant of an ADD or a SUB, not even MULs or DIVs, but you <em><strong>can</strong></em> catch it missing the <a href=https://www.ece.lsu.edu/ee4720/doc/riscv-bitmanip-1.0.0.pdf>zba, clz, or xnor</a> instructions, for example. Those, respectively, accelerate array indexing, count leading zeros, and perform an exclusive NOR. Capstone&rsquo;s current RISC-V <a href=https://github.com/capstone-engine/capstone/blob/9907b22d33693f3beb4b8b7ba261fbdd219afee3/include/capstone/riscv.h>disassembler</a> includes none of those instructions. We could argue whether those instructions are really &ldquo;Useful&rdquo; or &ldquo;Common&rdquo; in real software: but at the end of the day they&rsquo;re part of RISC-V, and any compliant RISC-V tool must be aware of them. Capstone sometimes also chokes on quite <a href=https://github.com/capstone-engine/capstone/issues/2278>basic</a> instructions, like LOAD.</p><blockquote><blockquote><p>RISC-V has a somewhat unusual approach to ISA evolution: it embraces extensions openly in its standard. Most architectures define new &ldquo;versions&rdquo; or &ldquo;editions&rdquo; whenever they change, RISC-V instead defines self-contained &ldquo;modules&rdquo; of behaviour and ISA state, even opening the door to vendors (companies selling SoCs and other products with RISC-V cores) to make their own vedor-defined extensions that co-exist with the rest of the architecture and its standard extensions. Each extension as well as the base architecture could evolve through different versions indepedently from other extensions. The RISC-V architecture is thus more of a family of architectures specified together rather than a single one.</p></blockquote></blockquote><p>Capstone was originally written based on codegen logic from LLVM. It’s essentially a port of LLVM disassembly logic from C++ to C (along with much simplification and cleaning up). Unfortunately, LLVM keeps updating that logic to reflect the fast-moving development and evolution of the architectures; those updates are not magically reflected back into Capstone! To make matters even worse, even LLVM proper can’t completely keep up with all the updates that happen to all the architectures it supports, it lags.</p><p>The Capstone project maintains an <a href=https://rizin.re/posts/auto-sync/>update tool</a> called <a href=https://github.com/capstone-engine/capstone/blob/next/suite/auto-sync/intro.md>Auto-Sync</a>, which can semi-automatically synchronize changes from LLVM to Capstone (using Tree-sitter magic). Alas, it can only do that for some architectures, and RISC-V is not among the supported ones. Also, we already saw how even LLVM is not completely on top of all updates. Fortunately, the solution exists, just hiding elswhere.</p><h1 id=to-sail-the-high-seas-and-risc-it-all>To Sail the high seas and RISC it all<a hidden class=anchor aria-hidden=true href=#to-sail-the-high-seas-and-risc-it-all>#</a></h1><p>The problem of describing Instruction Set Architectures (ISAs) accurately so that we can do plenty of useful things to them (assembly, disassembly, emulation, codegen, etc…) faces many projects and researchers, so much so that some smart people have developed an entirely new special language for it, Sail. Sail is a language designed specifically to address the problem of describing all aspects of ISAs: how the instructions are encoded into binary, how they execute, etc…</p><p>Now, if only there was a project that used Sail to describe RISC-V… wait, there is! It’s called Sail-RISCV. It’s such a complete and up-to-date description of RISC-V that the RISC-V foundation adopted it as the official source of truth for the architecture, this means that however the Sail code behaves, is - by definition - how RISC-V should behave.</p><blockquote><blockquote><p>Other architectures modelled in Sail are several versions of <a href=https://github.com/rems-project/sail-arm/tree/master>ARM</a>, a considerable part of <a href=https://github.com/rems-project/sail-x86-from-acl2>x86</a>, and a research version of MIPS called <a href=https://github.com/CTSRD-CHERI/sail-cheri-mips>CHERI-MIPS</a>, which includes hardware extensions to assist and accelerate memory safe pointers. The ARM and x86 models are auto-generated from other descriptions, and all 3 models are much less active than RISC-V&rsquo;s.</p></blockquote></blockquote><p>Let’s see a snippet of what Sail looks like in practice, here’s the definition of RISC-V IType (immediate) instructions:</p><p><img loading=lazy src=sail-itype-def.png alt></p><p>The rule might be as cryptic as latin if you’re not used to pattern-matching constructs from functional languages, but what it’s saying is simply the following:</p><ol><li>If the first (least-significant) 7 bits of the 32-bit instruction are: 0010011</li><li>And if the 3 bits from bit 12 to bit 14 are in the table encdec_iop</li><li>Then, the operation specified by this instruction is whatever enum corresponding to bits 12:14 in the encdec_iop table, and the args are:<ul><li>The 5-bit register index <strong>rd</strong> in bits 7 through 11</li><li>The 5-bit register index <strong>rs1</strong> in bits 15 through 19</li><li>The 12-bit literal <strong>imm</strong> in bits 20 through 31</li></ul></li><li>Otherwise, if (1) and (2) are not true, keep checking the 32-bit binary instruction against other rules</li></ol><blockquote><blockquote><p>In case you’re wondering what regidx is, it’s an alias for the type of 5-bit integers (or, as Sail calls them, bitvectors). Sail-RISCV uses it to refer to registers everywhere because register files in RISC-V always have 32 registers.</p></blockquote></blockquote><blockquote><blockquote><p>In case you’re wondering about the double arrow, that’s because this rule is a clause in a “Mapping”, a Sail innovation that basically means a bidirectional function: it can be used to decode binary instructions into structured objects, and to encode structured objects into binary instructions (that’s why it’s called encdec!).</p></blockquote></blockquote><p>Sail-RISCV contains ~280-290 rules of this form, and hundreds of other rules, sub-rules, and varied logic describing how RISC-V instructions are assembled, executed, how memory is accessed, how privliege levels and syscalls work, and so on.</p><p>We want this information, and we want it in C. We could port it by hand into C (good luck finishing in 2/3 years :(), or… we can use trusty code generation.</p><h1 id=risc-v-auto-sync>RISC-V Auto-Sync<a hidden class=anchor aria-hidden=true href=#risc-v-auto-sync>#</a></h1><p>So this is what my GSoC project this year was all about:</p><ol><li>Use Sail’s compiler (written in OCaml) as a library to load, parse, and typecheck Sail-RISCV</li><li>Process the AST of Sail-RISCV and generate data structures representing the important logic</li><li>Generate C code from those data structures</li></ol><p>That is, the code I wrote transformed the rule above into the following C code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// ---------------------------ITYPE-------------------------------
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (((binary_stream <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x000000000000007F</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x13</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>uint64_t</span> op <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xFFFFFFFFFFFFFFFF</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>switch</span> ((binary_stream <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x0000000000007000</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>12</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x7</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        op <span style=color:#f92672>=</span> RISCV_ANDI;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x3</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        op <span style=color:#f92672>=</span> RISCV_SLTIU;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x2</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        op <span style=color:#f92672>=</span> RISCV_SLTI;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x6</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        op <span style=color:#f92672>=</span> RISCV_ORI;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x4</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        op <span style=color:#f92672>=</span> RISCV_XORI;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x0</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        op <span style=color:#f92672>=</span> RISCV_ADDI;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (op <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0xFFFFFFFFFFFFFFFF</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint64_t</span> rd <span style=color:#f92672>=</span> (binary_stream <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x0000000000000F80</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint64_t</span> rs1 <span style=color:#f92672>=</span> (binary_stream <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x00000000000F8000</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>15</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint64_t</span> imm <span style=color:#f92672>=</span> (binary_stream <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x00000000FFF00000</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>20</span>;
</span></span><span style=display:flex><span>        tree<span style=color:#f92672>-&gt;</span>ast_node_type <span style=color:#f92672>=</span> RISCV_ITYPE;
</span></span><span style=display:flex><span>        tree<span style=color:#f92672>-&gt;</span>ast_node.itype.imm <span style=color:#f92672>=</span> imm;
</span></span><span style=display:flex><span>        tree<span style=color:#f92672>-&gt;</span>ast_node.itype.rs1 <span style=color:#f92672>=</span> rs1;
</span></span><span style=display:flex><span>        tree<span style=color:#f92672>-&gt;</span>ast_node.itype.rd <span style=color:#f92672>=</span> rd;
</span></span><span style=display:flex><span>        tree<span style=color:#f92672>-&gt;</span>ast_node.itype.op <span style=color:#f92672>=</span> op;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>//------------------------------------------------------------
</span></span></span></code></pre></div><p>This low-level soup of shifts and masks performs the exact logic described in the Sail snippet earlier, just in C. It continues on like that for 9K lines of generated code (<code>#include</code>ing approximately 2K lines of generated AST definition).</p><p>In addition to this, the logic that disassembles the decoded structured objects into strings is also translated. Overall, the generated code is about 20K of C, but it’s still not finished yet.</p><h1 id=loose-ends>Loose Ends<a hidden class=anchor aria-hidden=true href=#loose-ends>#</a></h1><p>The 20K of <a href=https://github.com/capstone-engine/capstone/pull/2498>generated C code</a> is still not merged into Capstone. Before merging, it must first incorporate additional logic into the generated decode functions, it must also infer the type of each operand (whether it’s a register, a memory address, or a literal. If it’s a register, is it floating point or integer, etc…). Those details can easily consume another writeup, but they&rsquo;re all managable.</p><p>The <a href=https://github.com/rizinorg/capstone-autosync-sail>generator</a> itself is ~2500 lines of idiomatic (I hope) OCaml. But since Sail is a complex language, the tool must make some assumptions about the input that might not survive the evolution of Sail-RISCV, the application to other Sail models, or the active evolution of Sail itself.</p><p>Finally, we haven’t addressed the original problem yet! I hope to eventually and finally write the grey arrow in the first diagram: Lifting RISC-V instructions to RzIL code.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>Let’s summarize this rollercoaster journey:</p><ol><li>We just wanted to write a binary lifter for RISC-V instructions into RzIL, Rizin’s intermediate language.</li><li>But in order to do that, we first have to have an up-to-date RISC-V decoder/disassembler.</li><li>Rizin depends on Capstone for RISC-V disassembly, but Capstone RISC-V disassembly logic is ported from old LLVM logic that is not up-to-date.</li><li>Even modern LLVM is not completely up-to-date with RISC-V.</li><li>But Sail-RISCV is, and it&rsquo;s adopted by the RISC-V foundation as the most authoritative model of the RISC-V architecture.</li><li>And thus, we can generate a Capstone disassembler module from Sail-RISCV, by depending on the Sail compiler as a library.</li></ol><p>It was fun. Frustrating and long-winded at times, but what kind of programming isn’t? That’s part of the thrill anyway!</p><p>That&rsquo;s all and Happy Holidays! Keep coding through the wind and the snow.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://rizin.re/tags/rizin/>rizin</a></li><li><a href=https://rizin.re/tags/capstone/>capstone</a></li><li><a href=https://rizin.re/tags/gsoc/>gsoc</a></li><li><a href=https://rizin.re/tags/rzil/>rzil</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share GSoC 2024 - RISC-V Capstone auto-sync and RzIL uplifting on twitter" href="https://twitter.com/intent/tweet/?text=GSoC%202024%20-%20RISC-V%20Capstone%20auto-sync%20and%20RzIL%20uplifting&amp;url=https%3a%2f%2frizin.re%2fposts%2fgsoc-2024-auto-sync-sail%2f&amp;hashtags=rizin%2ccapstone%2cgsoc%2crzil"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share GSoC 2024 - RISC-V Capstone auto-sync and RzIL uplifting on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frizin.re%2fposts%2fgsoc-2024-auto-sync-sail%2f&amp;title=GSoC%202024%20-%20RISC-V%20Capstone%20auto-sync%20and%20RzIL%20uplifting&amp;summary=GSoC%202024%20-%20RISC-V%20Capstone%20auto-sync%20and%20RzIL%20uplifting&amp;source=https%3a%2f%2frizin.re%2fposts%2fgsoc-2024-auto-sync-sail%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share GSoC 2024 - RISC-V Capstone auto-sync and RzIL uplifting on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frizin.re%2fposts%2fgsoc-2024-auto-sync-sail%2f&title=GSoC%202024%20-%20RISC-V%20Capstone%20auto-sync%20and%20RzIL%20uplifting"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share GSoC 2024 - RISC-V Capstone auto-sync and RzIL uplifting on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frizin.re%2fposts%2fgsoc-2024-auto-sync-sail%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share GSoC 2024 - RISC-V Capstone auto-sync and RzIL uplifting on whatsapp" href="https://api.whatsapp.com/send?text=GSoC%202024%20-%20RISC-V%20Capstone%20auto-sync%20and%20RzIL%20uplifting%20-%20https%3a%2f%2frizin.re%2fposts%2fgsoc-2024-auto-sync-sail%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share GSoC 2024 - RISC-V Capstone auto-sync and RzIL uplifting on telegram" href="https://telegram.me/share/url?text=GSoC%202024%20-%20RISC-V%20Capstone%20auto-sync%20and%20RzIL%20uplifting&amp;url=https%3a%2f%2frizin.re%2fposts%2fgsoc-2024-auto-sync-sail%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://rizin.re/>Rizin</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script defer src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById("menu").scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})});function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById("menu").scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>