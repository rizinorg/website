<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Auto-Sync - Generating disassembler plugins | Rizin</title><meta name=keywords content="dev,rizin,capstone"><meta name=description content="Auto-Sync"><meta name=author content="Rot127"><link rel=canonical href=https://rizin.re/posts/auto-sync/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://rizin.re/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rizin.re/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rizin.re/favicon-32x32.png><link rel=apple-touch-icon href=https://rizin.re/apple-touch-icon.png><link rel=mask-icon href=https://rizin.re/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link href=https://cdn.lineicons.com/2.0/LineIcons.css rel=stylesheet><link rel=stylesheet href=https://rizin.re/css/custom/rizin.min.f00018437c0f0fe081c2a5ccdb294666c6f0adc5f7ca5ce6f622496f40fc88ac.css><meta property="og:title" content="Auto-Sync - Generating disassembler plugins"><meta property="og:description" content="Auto-Sync"><meta property="og:type" content="article"><meta property="og:url" content="https://rizin.re/posts/auto-sync/"><meta property="og:image" content="https://rizin.re/images/rizin_preview.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-27T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-27T00:00:00+00:00"><meta property="og:site_name" content="Rizin"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rizin.re/images/rizin_preview.png"><meta name=twitter:title content="Auto-Sync - Generating disassembler plugins"><meta name=twitter:description content="Auto-Sync"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rizin.re/posts/"},{"@type":"ListItem","position":2,"name":"Auto-Sync - Generating disassembler plugins","item":"https://rizin.re/posts/auto-sync/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Auto-Sync - Generating disassembler plugins","name":"Auto-Sync - Generating disassembler plugins","description":"Auto-Sync","keywords":["dev","rizin","capstone"],"articleBody":"Updated on 2024.10.01\nA disassembler is obviously a must-have tool to do any reversing task. But using just any disassembler, especially for frameworks like Rizin, doesn’t really do it.\nThere are several capabilities which would be nice to have.\nIt should:\nBe correct. And if it isn’t, it should be easy to test and spot the error (in our case we want to compare the output directly to llvm-objdump). Provide a single API for multiple architectures. Support niche architectures or make it relatively easy to add them. Apart from the text disassembly, provide additional information about the operands and other meta-data. Be easy to update when new processor extensions come out. Relatively lightweight. Written in C or any other language that is easy to integrate into C/C++ software (specifically needed by Rizin/Cutter) One of the first disassembler engines which was capable of some of those points was Capstone. Quynh Nguyen Anh, the author of Capstone, figured that all the information we need, is basically already there in compiler projects like LLVM.\nObviously, for compilation you need the same and much more information you would need for disassembling. And you need them in a well-defined and machine-readable way.\nSo, what Capstone did, was re-implementing the LLVM disassembler logic in C, add meta-data for each instruction from the architecture definitions (also given in the LLVM-project) and add a single API to interact with it.\nTo summarize, Capstone is in the end:\nA more lightweight API than LLVM because it re-implements only the necessary code for disassembly from LLVM. Can support as many architectures as LLVM supports (if someone ports them to Capstone). Provides more information than the textual disassembly one gets via llvm-objdump. Relies on a well maintained and large project, which will (likely) be there even in 10+ years and is managed by people who know more about the architectures. The big problem with Capstone was though, that it hadn’t a working update mechanism. There were a bunch of Python scripts and very little documentation. Definitely an unsustainable solution.\nDue to this, Capstone became outdated over the years and most disassembler modules didn’t support modern processor extensions.\nWhat can be done? Besides LLVM we attempted once to generate a disassembler module for the Hexagon architecture (a DSP architecture from Qualcomm). But instead of LLVM, we used the ISA PDF for our first try. We parsed it and generated the decoding tables for the instructions. This worked, but was a little messy. Parsing PDF files is not fun and as soon as the PDF file changes somehow, stuff is broken again. Also, it is hard to test if you actually extracted the encoding information from the PDF correctly.\nOur second attempt uses LLVM. LLVM provides a way to get the definitions of an architecture in JSON format (llvm-tblgen --dump-json). The JSON dump has all the details about instructions you can wish for. Opcodes, operand types, read/write info and more. Pretty much anything you could wish for. With this experience we decided that LLVM proved to be a good source for disassembler generation.\nNow, with this experience we decided we could extend Capstone with a proper updater. The alternative, implementing something Capstone like from scratch in a new project, did not really seem a good idea. Capstone has already a large user base, and we would need to migrate to the new tool as well. The last point is maybe annoying but doable. Getting a user base again is a way harder task.\nSo over the last two years we added an updater to Capstone. With it, we updated some core modules (ARM, AArch64, PPC + Paired Single, SystemZ, Mips + NanoMips) and added new ones (Alpha, TriCore, Xtensa, HPPA). And to our delight jiegec and FurryAcetylCoA added support for LoongArch.\nIn the following blog post we’ll not just explain the update procedure in detail, but also reflect on some challenges and problems you run into when you generate disassemblers.\nHow LLVM generates its disassemblers LLVM is our ground truth Capstone is built on. So let’s start with it.\nHow is the LLVM disassembler generated and how does it work?\nLLVM defines its various supported architectures in a language, specifically designed for this purpose. Each target’s instructions, instruction operands, scheduling information and more is written in the TableGen language. The definitions can be found in llvm/lib/Target//*.td.\nPlease note, that from now on we use “target” and “architecture” are interchangeable terms. In the LLVM realm we speak about a target. In Capstone context about an architecture.\nSince each target is defined in the same way, LLVM can apply the same procedures on them to generate C++ code with it. This is way better than implementing every target directly in C++. Because otherwise a disassembler must be implemented again and again for each target. This would be of course too much effort. With TableGen every instruction is already well-defined in the td files. So, LLVM uses a universal method to generate a decoder for each of them. There is still some manual work left. E.g. handling edge cases and parsing operand bits. But the core logic is generated.\nTo use the content of the td files in a programmable way, the llvm-tblegen tool parses them and converts its content into C++ classes and saves them in a RecordKeeper. The RecordKeeper class is TableGen’s internal representation of the td files content. Which can now be used to generate arbitrary code. These classes basically hold all the td file information in a uniform and programmable way. The C++ classes belong logically to the so called CodeGen layer. Which, as the name already says, are used to generate code.\nExample:\nDefinition of the ARM setend instruction in TableGen:\ndef SETEND : AXI\u003c(outs), (ins setend_op:$end), MiscFrm, NoItinerary, \"setend\\t$end\", []\u003e, Requires\u003c[IsARM]\u003e, Deprecated\u003cHasV8Ops\u003e { bits\u003c1\u003e end; let Inst{31-10} = 0b1111000100000001000000; let Inst{9} = end; let Inst{8-0} = 0; } becomes a C++ class of the form of this\nSETEND {\t// InstructionEncoding Instruction InstTemplate Encoding InstARM XI AXI Requires Deprecated // Instruction bits, the operand bits are marked (in this case only one bit for \"end\"). field bits\u003c32\u003e Inst = { 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, end{0}, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; field bits\u003c32\u003e Unpredictable = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; field bits\u003c32\u003e SoftFail = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; int Size = 4; string DecoderNamespace = \"ARM\"; list\u003cPredicate\u003e Predicates = [IsARM]; string DecoderMethod = \"\"; bit hasCompleteDecoder = 1; string Namespace = \"ARM\"; // Note this list of in and out operands. Setend has only an operand which is read and no operands it writes. dag OutOperandList = (outs); dag InOperandList = (ins setend_op:$end); string AsmString = \"setend\t$end\"; list\u003cdag\u003e Pattern = []; list\u003cRegister\u003e Uses = []; list\u003cRegister\u003e Defs = []; int CodeSize = 0; int AddedComplexity = 0; bit isPreISelOpcode = 0; bit isReturn = 0; bit isBranch = 0; ... bit isBarrier = 0; bit isCall = 0; bit isAdd = 0; bit isTrap = 0; bit canFoldAsLoad = 0; bit mayLoad = ?; bit mayStore = ?; bit mayRaiseFPException = 0; ... bit doubleWidthResult = 0; SubtargetFeature DeprecatedFeatureMask = HasV8Ops; bits\u003c1\u003e end = { ? }; } Note, that the C++ class above has the same structure for each target. Hence, LLVM’s code generation, can reason on them without the need to know specific target details.\nNow, what code is actually generated? This depends on what you need. TableGen has several backends. Each of them uses the RecordKeeper's content to generate different files. For example, the RegisterInfo backend generates several tables with information about target registers. As mentioned above, the RegisterInfo backend doesn’t need to know details about targets specific registers. It just implements methods to generate an enumeration with all register names. Or it generates tables which map registers to their alias, or lookup tables which map bits to a register ID.\nGenerating enumerations is nice, but more complex C++ code is, of course, also generated. For us very relevant is the decoding logic, which decodes a byte sequence into a Machine Code instruction. A Machine Code instruction (MCInst) is the class which represents a target’s decoded instruction. It holds the ID of the instruction, its operands, some flags (isBranch etc.), and some more.\nDecoding procedures from bytes to MCInst are the same for each target (except x86, because historical reasons I guess). In the CodeGen layer we still know the encoding of each instruction of a target. Another backend, the DecoderEmitter, consumes these encodings and builds a state machine over them. The generated state machine simply checks certain bits and transitions into states. The end state is either an identified instruction or the disassembly failed. After the instruction ID is decoded, a big switch case is walked over to call the different decoder methods of the instruction’s operands.\nCheckout [`PPCGenDisassemblerTables.inc`](https://github.com/capstone-engine/capstone/blob/next/arch/PowerPC/PPCGenDisassemblerTables.inc). It contains this state machine. Or see the examples below. The key is: the state machine table and the big switch cases can be generated independently of the target. Each target still needs to implement the operand decoders, because those are unique, but this is essentially it. It saves quite some work, compared to implementing the decoding logic every time again and again.\nExcerpt from state machine\nstatic const uint8_t DecoderTableARM32[] = { // What to do in the state | Bits to check or to extract /* 0 */ MCD::OPC_ExtractField, 25, 3, // Extract 3 bits at offset 25 from byte sequence /* 3 */ MCD::OPC_FilterValue, 0, 47, 14, 0 // Check the certain bits for properties and transition to another state depending on the result. /* 8 */ MCD::OPC_ExtractField, 21, 1, /* 11 */ MCD::OPC_FilterValue, 0, 110, 7, 0 /* 16 */ MCD::OPC_ExtractField, 24, 1, /* 19 */ MCD::OPC_FilterValue, 0, 139, 1, 0 /* 24 */ MCD::OPC_ExtractField, 4, 1, /* 27 */ MCD::OPC_FilterValue, 0, 123, 0, 0 /* 32 */ MCD::OPC_ExtractField, 22, 2, /* 35 */ MCD::OPC_FilterValue, 0, 25, 0, 0 /* 40 */ MCD::OPC_CheckPredicate, 0, 11, 0, 0 // Check if a predicate is fulfilled (CPU feature X enabled etc.) and transision in a certain state depending on the result. ... Excerpt of the operand decoding switch statement\nswitch (Idx) { default: llvm_unreachable(\"Invalid index!\"); case 0: // Extract bits of operand tmp = fieldFromInstruction(insn, 12, 4); // Decode a GPR register and check if it worked. if (!Check(S, DecodeGPRRegisterClass(MI, tmp, Address, Decoder))) { return MCDisassembler::Fail; } tmp = fieldFromInstruction(insn, 16, 4); if (!Check(S, DecodeGPRRegisterClass(MI, tmp, Address, Decoder))) { return MCDisassembler::Fail; } tmp = fieldFromInstruction(insn, 0, 4); if (!Check(S, DecodeGPRRegisterClass(MI, tmp, Address, Decoder))) { return MCDisassembler::Fail; } tmp = fieldFromInstruction(insn, 28, 4); if (!Check(S, DecodePredicateOperand(MI, tmp, Address, Decoder))) { return MCDisassembler::Fail; } tmp = fieldFromInstruction(insn, 20, 1); if (!Check(S, DecodeCCOutOperand(MI, tmp, Address, Decoder))) { return MCDisassembler::Fail; } return S; A target’s disassembler module in LLVM consists effectively of two parts. The generated logic (those are written to .inc files) and handwritten decoder and printing methods. Decoders for operands like DecodeGPRRegisterClass from above, need to be implemented per target. They cannot be generated currently.\nThe handwritten code is in files like Disassembler.cpp or AsmWriter.cpp in their respective target source directories.\nLLVM to Capstone Capstone simply copies the LLVM disassembler and enriches the output. Because we do not want to build LLVM just to build Capstone (LLVM is a huge dependency), we have to tackle two problems:\nLLVM code is in C++, Capstone in C. The LLVM disassembler has no knowledge about read/write access of operands or instruction groups. Theoretically it could, but it is not implemented. For Capstone we need this information though. C++ and C For Capstone we need the C++ files in C. We also need the generated *.inc files, as well as handwritten disassembler components (Disassembler.cpp and AsmWriter.cpp from above).\nLets see how to get them in C.\nGenerate C code with TableGen We already described the generation procedure of the .inc files above in detail. Though what we have not mentioned is the way the actual code is emitted. The problem with the TableGen backends is, they do not separate the generation of their data from the actual printing of the code.\nFor example, the backend which generates the AsmWriter (the module which prints an asm string of an instruction) mixes it’s table generation with emitting code. There is no clear separation between generating abstract objects, like state machines and tables, and printing them into code. It is all intermingled.\nThis goes so far that it is even allowed to specify custom code in the td files for operands or instructions.\nSo, if we want TableGen backends emit C, we either need to redesign and rewrite them from scratch or patch them. Designing it from scratch is a rather complex task. And needs a lot of thought (see this discussion). Simply because of time constraints and because we don’t know if it will be merged, we sided with patching.\nOur patched TableGen backends work pretty straight forward. We add two new classes which only emit code. PrinterLLVM and PrinterCapstone. The PrinterLLVM emits the standard C++ code from LLVM. PrinterCapstone emits our C code. Each backend gets one of those printer classes assigned. And whenever it emits code, it calls the corresponding method of the printer. In practice, we simply moved the emitting code from the backend to the printer classes.\nGeneral design problems with TableGen backends The problem is, it is ugly. Although we are now able to emit C, it only works because C and C++ are so similar. An array initialization in C++ is almost the same as in C. So the code structure is basically the same. But there is no way to emit the same information (tables, functions etc.) in a different order or in a fundamentally different language (think of Lisp). This is a simple necessity how the backends were build. Because there is no clear separation between generating logic and printing it as code, the backends in the current form cannot be refactored nicely to emit code in other languages than C++.\nMost of it is also untouched for 10 years and was never modernized. This is understandable, since it never really was necessary. It works for the current use case (generate code for LLVM tools). But it doesn’t allow using the generated logic in any other way.\nFor example, the state machine for decoding bytes to instructions is useful logic. Also for non-LLVM projects. It could be written once and used by everyone else. But it is pretty much hard-coded to provide the state machine only in C++.\nThis is unfortunate. LLVM is a huge project, and many tools use the information about architectures it provides. Providing these kinds of often used algorithms in an accessible way, would be a nice addition.\nTranslating C++ to C But back to the problem at hand. While we have now the generated C code, we still have handwritten code in C++. As mentioned before, the operand decoder and printer methods are handwritten in LLVM. Additionally, some edge cases are handled there as well. These files have to be translated from C++ to C.\nDoing this by hand is a tedious task. We need to do it for every architecture module again and again. Because those files are not shared between targets. And if we add a new architecture module from LLVM to Capstone, we would need to translate multiple thousand lines of C++ to C.\nThis of cause is not particular fun and hinders people to do it at all. Hence, we built the Auto-Sync framework to do most of the annoying work.\nThe translation process follows a simple procedure. We have a bunch of patches defined. Each patch replaces certain syntax in an C++ file with its C equivalent.\nTo find the patterns we want to replace we use tree-sitter. It allows us to query for specific syntax in the abstract syntax tree (AST) of the file. And since we translate source code, it is way easier to search in an AST, instead in the file content itself.\nTo control the patching, we have a controller called CppTranslator. It simply:\nOpens each source file Reads and parses the file with tree-sitter into an AST for each Patch: Match the Patch’s tree-sitter query in the AST. If it found something, get the equivalent C code from the Patch. Replace the C++ code with the C equivalent. Example:\nMI::addImm(int(10)); Let’s say we want to patch int(10) to its C equivalent of (int)(10). The Patch for this has a tree-sitter query for this pattern:\n// The @ names elements in the query. (call_expression // Matches a call expression. (primitive_type) @cast_type // Matches primitive types like int, unsigned etc. (argument_list) @cast_target // Matches anything within the () brackets ) @cast If the CppTranslator finds a substring matching the pattern, it passes it as a capture to the Patch. A capture is just a dictionary with the named sub-strings found. In our example it contains cast: \"int(10)\", cast_type: \"int\" and cast_target: \"(10)\".\nNow it is trivial to concatenate sub-strings to (int)(10) and return it. The CppTranslator now replaces int(10) in the source file with (int)(10).\nThe result:\nMI::addImm((int)(10)); This is done with most C++ syntax. Of course, there are exceptions. Some C++ concepts are so complex to replace, we implement special scripts for them (e.g. C++ templates). But the end-result is a source file which has very little C++ syntax left.\nDiffing Note: The diffing step is still unstable and is not yet reproducable. Translating C++ files only gets so good. After all patches were applied to the file, it will likely not compile. Some syntax issues are just too difficult to fix automatically.\nFixing a handful of issues by hand again and again, is a tedious task. Especially, if you need to run the whole translation procedure multiple times. We can hardly ask users to do the fixes by hand again every time they ran the translator.\nThe mechanism to solve this annoyance is diffing. It basically works as you know it from git. The difference is it isn’t file focused like git but diffs tree-sitter queries. You can decide what to diff in the configuration, but let’s go over it in an example:\nSo let’s assume we update a fictional architecture.\nWe have an old Disassembler.c file which might need an update. In there we have a function which decodes an operand:\nvoid decodeOperandA(MCInst *MI, unsigned OpNum, unsigned Val) { if (MCInst_isPredicable(MI)) { MCOperand_CreateImm0(MI, Val + 1); } MCOperand_CreateImm0(MI, Val); } The same function in the original C++ file looks like this:\nvoid decodeOperandA(MCInst \u0026MI, unsigned OpNum, unsigned Val) { if (MI.isPredicable()) { MI.createImm(Val + 1); } MI.createImm(Val); } Now, after we ran the CppTranslator the result is almost valid C. But the translation was not perfect and there is still a method invocation left:\nvoid decodeOperandA(MCInst *MI, unsigned OpNum, unsigned Val) { if (MI.isPredicable()) { // The isPredicable method call was not translated. MCOperand_CreateImm0(MI, Val + 1); } MCOperand_CreateImm0(MI, Val); } Capstone’s MCInst struct doesn’t have a callback member isPredicable(). So this code would not compile. Instead, we need to replace it with the function call MCInst_isPredicable(MI).\nFor whatever reason no Patch was added, and we now have to fix it by hand. Note though that the old file (see above) already has the correct function implementation. So instead of fixing it again by hand, we diff the previous function to the newly translated code and let the user decide what to do.\nPatch: 15/230 Node: \"Some Node\" +Color: NEW FILE - (Just translated) -Color: OLD FILE - (Currently in Capstone) ⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼ void decodeOperandA(MCInst *MI, unsigned OpNum, unsigned Val) { -\tif (MCInst_isPredicable(MI)) { +\tif (MI.isPredicable()) { MCOperand_CreateImm0(MI, Val + 1); } MCOperand_CreateImm0(MI, Val); } ═════════════════════════════════════════════════════════════════════════════════════════════════════════ Choice: O, o, n, s (none) , e, p, q, ? \u003e ? O\t- Accept ALL old diffs o\t- Accept old diff n\t- Accept new diff e\t- Edit diff (not yet implemented) s (none) - Select saved choice p\t- Ignore and go to previous diff q\t- Quit (previous selections will be saved) ?\t- Show this help They can accept the version from the old file or accept the version from the new file. The version from the new file would not compile, but it can be fixes by hand later.\nIn most cases though, the old version is the correct one, because it was fixed by someone before.\nThe diffing happens for each translated function which doesn’t match the old code. Of course, you can not just diff functions but any nodes in the AST of a file. And for convenience the choices are saved as well. So if the update is run again and nothing changed, the user doesn’t have to redo previous decisions. It just automatically applies them.\nThis diffing step saves a lot of time.\nAdding new architectures Adding a new architecture module works pretty much the same as above.\nGenerally though it gives us a standardized way of doing it. And if you know one architecture module in Capstone, you know them all. If LLVM doesn’t support your architecture you maybe find a fork which does (this is the case for TriCore or EVM).\nIn fact, we added two niche architectures this way. TriCore was only implemented in a fork and never upstreamed. And the DEC Alpha architecture support was dropped in LLVM 4. We just added the td files again, and here we go, we have support for Alpha in Capstone.\nLast overview To give you a last overview what components were updated and how they interact in Capstone, take a look at this diagram:\nARCH_LLVM_getInstr( ARCH_getInstr(bytes) ┌───┐ bytes) ┌─────────┐ ┌──────────┐ ┌──────────────────────►│ A ├──────────────────► │ ├───────────►│ ├────┐ │ │ R │ │ LLVM │ │ LLVM │ │ Decode │ │ C │ │ │ │ │ │ Instr. │ │ H │ │ │decode(Op0) │ │◄───┘ ┌────────┐ disasm(bytes) ┌──────────┴──┐ │ │ │ Disass- │ ◄──────────┤ Decoder │ │CS Core ├──────────────►│ ARCH Module │ │ │ │ embler ├──────────► │ State │ └────────┘ └─────────────┘ │ M │ │ │ │ Machine │ ▲ │ A │ │ │decode(Op1) │ │ │ │ P │ │ │ ◄──────────┤ │ │ │ P │ │ ├──────────► │ │ │ │ I │ │ │ │ │ │ │ N │ │ │ │ │ └───────────────────────┤ G │◄───────────────────┤ │◄───────────┤ │ └───┘ └─────────┘ └──────────┘ The Capstone Core, Arch Module and Arch_Mapping provide the API to the LLVM disassembler logic. We have not spoken about those because they are irrelevant for the topic of generating disassemblers.\nThe two boxes on the right, are the code copies from LLVM, which do the actual decoding work. The LLVM Disassembler component decodes single operands and handles special cases. This one was translated by the CppTranslator. While the LLVM Decoder State Machine was generated by our patched LLVM backends.\nThe same structure applies to the printing of the asm text. Though we have only scratched this here for the sake of brevity.\nWrap up If one looks at the whole update procedure, it is still a rather complicated. But the result is worth it.\nThe amount of time someone has to spend for updating an architecture module in Capstone went down from “no one did it” to roughly 6-29 hours. To update the ARM architecture module to LLVM 16 for example, the times were:\nRebasing patched backends to new LLVM release = ~1-3h Running the update scripts and diffing = 5min - 1h Fixing rest of build errors by hand = ~30min - 5h Handle new operands on the CS side (filling the detail info and tests) - 3-10h Bug fixing - 2h-10h (Please be aware though, that the time estimates from above don’t include the “read into” time someone has to spend).\nThe lower estimates are for small changes on the LLVM side, the upper for many changes (spanning multiple LLVM releases).\nHere is process described above in action:\nFuture plans We have a list of features and architectures which will come. Most architectures are already updated, but ARC, BPF and SPARC are still on the list.\nWhile working on the updater we found many shortcomings or flaws in the target definitions in LLVM. Those will be upstreamed to LLVM eventually.\nIn the very long run we would like to participate with the LLVM folks in redesign the TableGen backends. It would be nice to have the problems solved, which we mentioned above.\nAnd of course, if you want to update now an already present Capstone module or add support for a new one, feel free to drop a message in issue #2015. We are happy to hear about it and will guide you through the process.\nReferences Auto-Sync progress issue Auto-Sync documentation TableGen documentation Capstone’s LLVM fork ","wordCount":"4202","inLanguage":"en","datePublished":"2024-01-27T00:00:00Z","dateModified":"2024-01-27T00:00:00Z","author":{"@type":"Person","name":"Rot127"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rizin.re/posts/auto-sync/"},"publisher":{"@type":"Organization","name":"Rizin","logo":{"@type":"ImageObject","url":"https://rizin.re/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>.theme-toggle{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://rizin.re/ accesskey=h>Rizin</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t title="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://rizin.re/posts/ target><span>Blog</span></a></li><li><a href=https://rizin.re/organization/ target><span>Organization</span></a></li><li><a href=https://rizin.re/community/ target><span>Community</span></a></li><li><a href=https://rizin.re/gsoc/ target><span>GSoC</span></a></li><li><a href=https://cutter.re target=_blank><span>Cutter</span></a></li><li><a href=https://github.com/rizinorg/rizin target=_blank><i class="lni lni-github-original"></i>
<span>Source</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rizin.re/>Home</a>&nbsp;»&nbsp;<a href=https://rizin.re/posts/>Posts</a></div><h1 class=post-title>Auto-Sync - Generating disassembler plugins</h1><div class=post-meta><span title='2024-01-27 00:00:00 +0000 UTC'>January 27, 2024</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;Rot127</div></header><div class=post-content><p><em>Updated on 2024.10.01</em></p><p>A disassembler is obviously a must-have tool to do any reversing task.
But using just any disassembler, especially for frameworks like Rizin, doesn&rsquo;t really do it.</p><p>There are several capabilities which would be nice to have.</p><p>It should:</p><ul><li>Be correct. And if it isn&rsquo;t, it should be easy to test and spot the error (in our case we want to compare the output directly to <code>llvm-objdump</code>).</li><li>Provide a single API for multiple architectures.</li><li>Support niche architectures or make it relatively easy to add them.</li><li>Apart from the text disassembly, provide additional information about the operands and other meta-data.</li><li>Be easy to update when new processor extensions come out.</li><li>Relatively lightweight.</li><li>Written in C or any other language that is easy to integrate into C/C++ software (specifically needed by Rizin/Cutter)</li></ul><p>One of the first disassembler engines which was capable of some of those points was Capstone.
Quynh Nguyen Anh, the author of Capstone, figured that all the information we need, is basically
already there in compiler projects like LLVM.</p><p>Obviously, for compilation you need the same and much more information you would need for disassembling.
And you need them in a well-defined and machine-readable way.</p><p>So, what Capstone did, was re-implementing the LLVM disassembler logic in C,
add meta-data for each instruction from the architecture definitions (also given in the LLVM-project)
and add a single API to interact with it.</p><p>To summarize, Capstone is in the end:</p><ul><li>A more lightweight API than LLVM because it re-implements only the necessary code for disassembly from LLVM.</li><li>Can support as many architectures as LLVM supports (if someone ports them to Capstone).</li><li>Provides more information than the textual disassembly one gets via <code>llvm-objdump</code>.</li><li>Relies on a well maintained and large project, which will (likely) be there even in 10+ years and is managed by people who know more about the architectures.</li></ul><p>The big problem with Capstone was though, that it hadn&rsquo;t a working update mechanism.
There were a bunch of Python scripts and very little documentation. Definitely an unsustainable solution.</p><p>Due to this, Capstone became outdated over the years and most disassembler modules
didn&rsquo;t support modern processor extensions.</p><h2 id=what-can-be-done>What can be done?<a hidden class=anchor aria-hidden=true href=#what-can-be-done>#</a></h2><p>Besides LLVM we attempted once to generate a disassembler module for the Hexagon architecture (a DSP architecture from Qualcomm). But instead of LLVM, we used the ISA PDF for our first try.
We parsed it and generated the decoding tables for the instructions.
This worked, but was a little messy. Parsing PDF files is not fun and as soon as the PDF file changes somehow, stuff is broken again.
Also, it is hard to test if you actually extracted the encoding information from the PDF correctly.</p><p>Our second attempt uses LLVM. LLVM provides a way to get the definitions of an architecture in JSON format (<code>llvm-tblgen --dump-json</code>). The JSON dump has all the details about instructions you can wish for.
Opcodes, operand types, read/write info and more. Pretty much anything you could wish for.
With this experience we decided that LLVM proved to be a good source for disassembler generation.</p><p>Now, with this experience we decided we could extend Capstone with a proper updater.
The alternative, implementing something Capstone like from scratch in a new project, did not really seem a good idea.
Capstone has already a large user base, and we would need to migrate to the new tool as well.
The last point is maybe annoying but doable. Getting a user base again is a way harder task.</p><p>So over the last two years we added an updater to Capstone.
With it, we updated some core modules (<code>ARM</code>, <code>AArch64</code>, <code>PPC</code> + <code>Paired Single</code>, <code>SystemZ</code>, <code>Mips</code> + <code>NanoMips</code>) and added new ones (<code>Alpha</code>, <code>TriCore</code>, <code>Xtensa</code>, <code>HPPA</code>).
And to our delight <a href=https://github.com/jiegec>jiegec</a> and <a href=https://github.com/FurryAcetylCoA>FurryAcetylCoA</a> added support for LoongArch.</p><p>In the following blog post we&rsquo;ll not just explain the update procedure in detail,
but also reflect on some challenges and problems you run into when you generate
disassemblers.</p><h1 id=how-llvm-generates-its-disassemblers>How LLVM generates its disassemblers<a hidden class=anchor aria-hidden=true href=#how-llvm-generates-its-disassemblers>#</a></h1><p><a href=https://github.com/llvm/llvm-project/tree/main/>LLVM</a> is our ground truth Capstone is built on. So let&rsquo;s start with it.</p><p><strong>How is the LLVM disassembler generated and how does it work?</strong></p><p>LLVM defines its various supported architectures in a language, specifically designed for this purpose.
Each target&rsquo;s instructions, instruction operands, scheduling information and more is written in the <a href=https://llvm.org/docs/TableGen/ProgRef.html>TableGen</a> language.
The definitions can be found in <code>llvm/lib/Target/&lt;TARGET-NAME>/*.td</code>.</p><blockquote><p>Please note, that from now on we use &ldquo;target&rdquo; and &ldquo;architecture&rdquo; are interchangeable terms.
In the LLVM realm we speak about a target. In Capstone context about an architecture.</p></blockquote><p>Since each target is defined in the same way, LLVM can apply the same procedures on them to generate C++ code with it.
This is way better than implementing every target directly in C++.
Because otherwise a disassembler must be implemented again and again for each target. This would be of course too much effort.
With TableGen every instruction is already well-defined in the <code>td</code> files. So, LLVM uses a universal method to generate a decoder for each of them.
There is still some manual work left. E.g. handling edge cases and parsing operand bits. But the core logic is generated.</p><p>To use the content of the <code>td</code> files in a programmable way, the <code>llvm-tblegen</code> tool parses them and converts its content into C++ classes and saves them in a <code>RecordKeeper</code>.
The <code>RecordKeeper</code> class is TableGen&rsquo;s internal representation of the <code>td</code> files content. Which can now be used to generate arbitrary code.
These classes basically hold all the <code>td</code> file information in a uniform and programmable way.
The C++ classes belong logically to the so called <code>CodeGen</code> layer. Which, as the name already says, are used to generate code.</p><p>Example:</p><p>Definition of the ARM <code>setend</code> instruction in TableGen:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>SETEND</span> : AXI<span style=color:#f92672>&lt;</span>(outs), (ins setend_op:<span style=color:#960050;background-color:#1e0010>$</span>end), MiscFrm, NoItinerary,
</span></span><span style=display:flex><span>                 <span style=color:#e6db74>&#34;setend</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>$end&#34;</span>, []<span style=color:#f92672>&gt;</span>, Requires<span style=color:#f92672>&lt;</span>[IsARM]<span style=color:#f92672>&gt;</span>, Deprecated<span style=color:#f92672>&lt;</span>HasV8Ops<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>  bits<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>&gt;</span> end;
</span></span><span style=display:flex><span>  let Inst{<span style=color:#ae81ff>31</span><span style=color:#f92672>-</span><span style=color:#ae81ff>10</span>} <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b1111000100000001000000</span>;
</span></span><span style=display:flex><span>  let Inst{<span style=color:#ae81ff>9</span>} <span style=color:#f92672>=</span> end;
</span></span><span style=display:flex><span>  let Inst{<span style=color:#ae81ff>8</span><span style=color:#f92672>-</span><span style=color:#ae81ff>0</span>} <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>becomes a C++ class of the form of this</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>SETEND {	<span style=color:#75715e>// InstructionEncoding Instruction InstTemplate Encoding InstARM XI AXI Requires Deprecated
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Instruction bits, the operand bits are marked (in this case only one bit for &#34;end&#34;).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  field bits<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>32</span><span style=color:#f92672>&gt;</span> Inst <span style=color:#f92672>=</span> { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, end{<span style=color:#ae81ff>0</span>}, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>  field bits<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>32</span><span style=color:#f92672>&gt;</span> Unpredictable <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>  field bits<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>32</span><span style=color:#f92672>&gt;</span> SoftFail <span style=color:#f92672>=</span> { <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span> };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> Size <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>  string DecoderNamespace <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ARM&#34;</span>;
</span></span><span style=display:flex><span>  list<span style=color:#f92672>&lt;</span>Predicate<span style=color:#f92672>&gt;</span> Predicates <span style=color:#f92672>=</span> [IsARM];
</span></span><span style=display:flex><span>  string DecoderMethod <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>  bit hasCompleteDecoder <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  string Namespace <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;ARM&#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Note this list of in and out operands. Setend has only an operand which is read and no operands it writes.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  dag OutOperandList <span style=color:#f92672>=</span> (outs);
</span></span><span style=display:flex><span>  dag InOperandList <span style=color:#f92672>=</span> (ins setend_op:<span style=color:#960050;background-color:#1e0010>$</span>end);
</span></span><span style=display:flex><span>  string AsmString <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;setend	$end&#34;</span>;
</span></span><span style=display:flex><span>  list<span style=color:#f92672>&lt;</span>dag<span style=color:#f92672>&gt;</span> Pattern <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  list<span style=color:#f92672>&lt;</span>Register<span style=color:#f92672>&gt;</span> Uses <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  list<span style=color:#f92672>&lt;</span>Register<span style=color:#f92672>&gt;</span> Defs <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> CodeSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> AddedComplexity <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  bit isPreISelOpcode <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  bit isReturn <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  bit isBranch <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span>  bit isBarrier <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  bit isCall <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  bit isAdd <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  bit isTrap <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  bit canFoldAsLoad <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  bit mayLoad <span style=color:#f92672>=</span> <span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>  bit mayStore <span style=color:#f92672>=</span> <span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>  bit mayRaiseFPException <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	...
</span></span><span style=display:flex><span>  bit doubleWidthResult <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  SubtargetFeature DeprecatedFeatureMask <span style=color:#f92672>=</span> HasV8Ops;
</span></span><span style=display:flex><span>  bits<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>&gt;</span> end <span style=color:#f92672>=</span> { <span style=color:#f92672>?</span> };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note, that the C++ class above has the same structure for each target. Hence, LLVM&rsquo;s code generation, can reason on them without the need to know specific target details.</p><p>Now, what code is actually generated? This depends on what you need. TableGen has several backends.
Each of them uses the <code>RecordKeeper's</code> content to generate different files.
For example, the <a href=https://github.com/llvm/llvm-project/blob/main/llvm/utils/TableGen/RegisterInfoEmitter.cpp>RegisterInfo</a> backend generates several tables with information about target registers.
As mentioned above, the <code>RegisterInfo</code> backend doesn&rsquo;t need to know details about targets specific registers.
It just implements methods to generate an enumeration with all register names. Or it generates tables which map registers to their alias, or lookup tables which map bits to a register ID.</p><p>Generating enumerations is nice, but more complex C++ code is, of course, also generated.
For us very relevant is the decoding logic, which decodes a byte sequence into a Machine Code instruction.
A Machine Code instruction (<code>MCInst</code>) is the class which represents a target&rsquo;s decoded instruction.
It holds the ID of the instruction, its operands, some flags (<code>isBranch</code> etc.), and some more.</p><p>Decoding procedures from bytes to <code>MCInst</code> are the same for each target (except x86, because <em>historical reasons</em> I guess).
In the CodeGen layer we still know the encoding of each instruction of a target. Another backend, the <code>DecoderEmitter</code>, consumes these encodings and
builds a state machine over them. The generated state machine simply checks certain bits and transitions into states. The end state is either an identified instruction or the disassembly failed.
After the instruction ID is decoded, a big switch case is walked over to call the different decoder methods of the instruction&rsquo;s operands.</p><pre><code>Checkout [`PPCGenDisassemblerTables.inc`](https://github.com/capstone-engine/capstone/blob/next/arch/PowerPC/PPCGenDisassemblerTables.inc). It contains this state machine. Or see the examples below.
</code></pre><p>The key is: the state machine table and the big switch cases can be generated independently of the target.
Each target still needs to implement the operand decoders, because those are unique, but this is essentially it.
It saves quite some work, compared to implementing the decoding logic every time again and again.</p><p><strong>Excerpt from state machine</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint8_t</span> DecoderTableARM32[] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>//            What to do in the state | Bits to check or to extract
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/* 0 */</span>       MCD<span style=color:#f92672>::</span>OPC_ExtractField, <span style=color:#ae81ff>25</span>, <span style=color:#ae81ff>3</span>, <span style=color:#75715e>// Extract 3 bits at offset 25 from byte sequence
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/* 3 */</span>       MCD<span style=color:#f92672>::</span>OPC_FilterValue, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>47</span>, <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>0</span> <span style=color:#75715e>// Check the certain bits for properties and transition to another state depending on the result.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>/* 8 */</span>       MCD<span style=color:#f92672>::</span>OPC_ExtractField, <span style=color:#ae81ff>21</span>, <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span><span style=color:#75715e>/* 11 */</span>      MCD<span style=color:#f92672>::</span>OPC_FilterValue, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>110</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 16 */</span>      MCD<span style=color:#f92672>::</span>OPC_ExtractField, <span style=color:#ae81ff>24</span>, <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span><span style=color:#75715e>/* 19 */</span>      MCD<span style=color:#f92672>::</span>OPC_FilterValue, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>139</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 24 */</span>      MCD<span style=color:#f92672>::</span>OPC_ExtractField, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span><span style=color:#75715e>/* 27 */</span>      MCD<span style=color:#f92672>::</span>OPC_FilterValue, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>123</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 32 */</span>      MCD<span style=color:#f92672>::</span>OPC_ExtractField, <span style=color:#ae81ff>22</span>, <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span><span style=color:#75715e>/* 35 */</span>      MCD<span style=color:#f92672>::</span>OPC_FilterValue, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>25</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 40 */</span>      MCD<span style=color:#f92672>::</span>OPC_CheckPredicate, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span> <span style=color:#75715e>// Check if a predicate is fulfilled (CPU feature X enabled etc.) and transision in a certain state depending on the result.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>...
</span></span></code></pre></div><p><strong>Excerpt of the operand decoding switch statement</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#66d9ef>switch</span> (Idx) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span> llvm_unreachable(<span style=color:#e6db74>&#34;Invalid index!&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Extract bits of operand
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    tmp <span style=color:#f92672>=</span> fieldFromInstruction(insn, <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Decode a GPR register and check if it worked.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>Check(S, DecodeGPRRegisterClass(MI, tmp, Address, Decoder))) { <span style=color:#66d9ef>return</span> MCDisassembler<span style=color:#f92672>::</span>Fail; }
</span></span><span style=display:flex><span>    tmp <span style=color:#f92672>=</span> fieldFromInstruction(insn, <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>Check(S, DecodeGPRRegisterClass(MI, tmp, Address, Decoder))) { <span style=color:#66d9ef>return</span> MCDisassembler<span style=color:#f92672>::</span>Fail; }
</span></span><span style=display:flex><span>    tmp <span style=color:#f92672>=</span> fieldFromInstruction(insn, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>Check(S, DecodeGPRRegisterClass(MI, tmp, Address, Decoder))) { <span style=color:#66d9ef>return</span> MCDisassembler<span style=color:#f92672>::</span>Fail; }
</span></span><span style=display:flex><span>    tmp <span style=color:#f92672>=</span> fieldFromInstruction(insn, <span style=color:#ae81ff>28</span>, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>Check(S, DecodePredicateOperand(MI, tmp, Address, Decoder))) { <span style=color:#66d9ef>return</span> MCDisassembler<span style=color:#f92672>::</span>Fail; }
</span></span><span style=display:flex><span>    tmp <span style=color:#f92672>=</span> fieldFromInstruction(insn, <span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>Check(S, DecodeCCOutOperand(MI, tmp, Address, Decoder))) { <span style=color:#66d9ef>return</span> MCDisassembler<span style=color:#f92672>::</span>Fail; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> S;
</span></span></code></pre></div><p>A target&rsquo;s disassembler module in LLVM consists effectively of two parts. The generated logic (those are written to <code>.inc</code> files) and handwritten decoder and printing methods.
Decoders for operands like <code>DecodeGPRRegisterClass</code> from above, need to be implemented per target. They cannot be generated currently.</p><p>The handwritten code is in files like <code>&lt;ARCH>Disassembler.cpp</code> or <code>&lt;ARCH>AsmWriter.cpp</code> in their
respective target source directories.</p><h2 id=llvm-to-capstone>LLVM to Capstone<a hidden class=anchor aria-hidden=true href=#llvm-to-capstone>#</a></h2><p>Capstone simply copies the LLVM disassembler and enriches the output.
Because we do not want to build LLVM just to build Capstone (LLVM is a huge dependency), we have to tackle two problems:</p><ul><li>LLVM code is in C++, Capstone in C.</li><li>The LLVM disassembler has no knowledge about read/write access of operands or instruction groups. Theoretically it could, but it is not implemented. For Capstone we need this information though.</li></ul><h3 id=c-and-c>C++ and C<a hidden class=anchor aria-hidden=true href=#c-and-c>#</a></h3><p>For Capstone we need the C++ files in C. We also need the generated <code>*.inc</code> files, as well as handwritten disassembler components (<code>&lt;ARCH>Disassembler.cpp</code> and <code>&lt;ARCH>AsmWriter.cpp</code> from above).</p><p>Lets see how to get them in C.</p><h3 id=generate-c-code-with-tablegen>Generate C code with TableGen<a hidden class=anchor aria-hidden=true href=#generate-c-code-with-tablegen>#</a></h3><p>We already described the generation procedure of the <code>.inc</code> files above in detail.
Though what we have not mentioned is the way the actual code is emitted. The problem with the TableGen backends is, they do not separate the generation of their data from the actual printing of the code.</p><p>For example, the backend which generates the <a href=https://github.com/capstone-engine/llvm-capstone/blob/auto-sync/llvm/utils/TableGen/AsmWriterEmitter.cpp><code>AsmWriter</code></a> (the module which prints an asm string of an instruction) mixes it&rsquo;s table generation with emitting code.
There is no clear separation between generating abstract objects, like state machines and tables, and printing them into code. It is all intermingled.</p><p>This goes so far that it is even allowed to specify custom code in the <code>td</code> files for operands or instructions.</p><p>So, if we want TableGen backends emit C, we either need to redesign and rewrite them from scratch or patch them.
Designing it from scratch is a rather complex task. And needs a lot of thought (<a href=https://reviews.llvm.org/D138323>see this discussion</a>).
Simply because of time constraints and because we don&rsquo;t know if it will be merged, we sided with patching.</p><p>Our <a href=https://github.com/capstone-engine/llvm-capstone>patched TableGen</a> backends work pretty straight forward. We add two new classes which only emit code.
<a href=https://github.com/capstone-engine/llvm-capstone/blob/auto-sync/llvm/utils/TableGen/PrinterLLVM.cpp><code>PrinterLLVM</code></a> and <a href=https://github.com/capstone-engine/llvm-capstone/blob/auto-sync/llvm/utils/TableGen/PrinterCapstone.cpp><code>PrinterCapstone</code></a>.
The <code>PrinterLLVM</code> emits the standard C++ code from LLVM. <code>PrinterCapstone</code> emits our C code.
Each backend gets one of those printer classes assigned. And whenever it emits code, it calls the corresponding method of the printer.
In practice, we simply moved the emitting code from the backend to the printer classes.</p><h3 id=general-design-problems-with-tablegen-backends>General design problems with TableGen backends<a hidden class=anchor aria-hidden=true href=#general-design-problems-with-tablegen-backends>#</a></h3><p>The problem is, it is ugly. Although we are now able to emit C, it only works because C and C++ are so similar.
An array initialization in C++ is almost the same as in C. So the code structure is basically the same.
But there is no way to emit the same information (tables, functions etc.) in a different order or in a fundamentally different language (think of Lisp).
This is a simple necessity how the backends were build. Because there is no clear separation between generating logic and printing it as code,
the backends in the current form cannot be refactored nicely to emit code in other languages than C++.</p><p>Most of it is also untouched for 10 years and was never modernized. This is understandable, since it never really was necessary.
It works for the current use case (generate code for LLVM tools). But it doesn&rsquo;t allow using the generated logic in any other way.</p><p>For example, the state machine for decoding bytes to instructions is useful logic. Also for non-LLVM projects. It could be written once and used by everyone else.
But it is pretty much hard-coded to provide the state machine only in C++.</p><p>This is unfortunate. LLVM is a huge project, and many tools use the information about architectures it provides.
Providing these kinds of often used algorithms in an accessible way, would be a nice addition.</p><h3 id=translating-c-to-c>Translating C++ to C<a hidden class=anchor aria-hidden=true href=#translating-c-to-c>#</a></h3><p>But back to the problem at hand. While we have now the generated C code, we still have handwritten code in C++.
As mentioned before, the operand decoder and printer methods are handwritten in LLVM. Additionally, some edge cases are handled there as well.
These files have to be translated from C++ to C.</p><p>Doing this by hand is a tedious task. We need to do it for every architecture module again and again. Because those files are not shared between targets.
And if we add a new architecture module from LLVM to Capstone, we would need to
translate multiple thousand lines of C++ to C.</p><p>This of cause is not particular fun and hinders people to do it at all.
Hence, we built the Auto-Sync framework to do most of the annoying work.</p><p>The translation process follows a simple procedure. We have a bunch of patches defined. Each patch replaces certain syntax in an C++ file with its C equivalent.</p><p>To find the patterns we want to replace we use <a href=https://tree-sitter.github.io/tree-sitter/>tree-sitter</a>. It allows us to query for specific syntax in the abstract syntax tree (AST) of the file.
And since we translate source code, it is way easier to search in an AST, instead in the file content itself.</p><p>To control the patching, we have a controller called <a href=https://github.com/capstone-engine/capstone/tree/next/suite/auto-sync/Updater/CppTranslator><code>CppTranslator</code></a>. It simply:</p><ul><li>Opens each source file</li><li>Reads and parses the file with <code>tree-sitter</code> into an AST</li><li>for each <code>Patch</code>:<ul><li>Match the <code>Patch</code>&rsquo;s <a href=https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries>tree-sitter query</a> in the AST.</li><li>If it found something, get the equivalent C code from the <code>Patch</code>.</li><li>Replace the C++ code with the C equivalent.</li></ul></li></ul><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>MI<span style=color:#f92672>::</span>addImm(<span style=color:#66d9ef>int</span>(<span style=color:#ae81ff>10</span>));
</span></span></code></pre></div><p>Let&rsquo;s say we want to patch <code>int(10)</code> to its C equivalent of <code>(int)(10)</code>.
The <code>Patch</code> for this has a <code>tree-sitter</code> query for this pattern:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// The @ names elements in the query.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>(call_expression <span style=color:#75715e>// Matches a call expression.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  (primitive_type) <span style=color:#960050;background-color:#1e0010>@</span>cast_type <span style=color:#75715e>// Matches primitive types like int, unsigned etc.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  (argument_list) <span style=color:#960050;background-color:#1e0010>@</span>cast_target <span style=color:#75715e>// Matches anything within the () brackets
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>) <span style=color:#960050;background-color:#1e0010>@</span>cast
</span></span></code></pre></div><p>If the <code>CppTranslator</code> finds a substring matching the pattern, it passes it as a <code>capture</code> to the <code>Patch</code>.
A <code>capture</code> is just a dictionary with the named sub-strings found. In our example it contains <code>cast: "int(10)"</code>, <code>cast_type: "int"</code> and <code>cast_target: "(10)"</code>.</p><p>Now it is trivial to concatenate sub-strings to <code>(int)(10)</code> and return it.
The <code>CppTranslator</code> now replaces <code>int(10)</code> in the source file with <code>(int)(10)</code>.</p><p>The result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>MI<span style=color:#f92672>::</span>addImm((<span style=color:#66d9ef>int</span>)(<span style=color:#ae81ff>10</span>));
</span></span></code></pre></div><p>This is done with most C++ syntax. Of course, there are exceptions. Some C++ concepts are so complex to replace, we implement special scripts for them (e.g. C++ templates).
But the end-result is a source file which has very little C++ syntax left.</p><h2 id=diffing>Diffing<a hidden class=anchor aria-hidden=true href=#diffing>#</a></h2><pre><code>Note: The diffing step is still unstable and is not yet reproducable.
</code></pre><p>Translating C++ files only gets so good. After all patches were applied to the file, it will likely not compile. Some syntax issues are just too difficult to fix automatically.</p><p>Fixing a handful of issues by hand again and again, is a tedious task. Especially, if you need to run the whole translation procedure multiple times.
We can hardly ask users to do the fixes by hand again every time they ran the translator.</p><p>The mechanism to solve this annoyance is diffing. It basically works as you know it from <code>git</code>.
The difference is it isn&rsquo;t file focused like <code>git</code> but diffs <code>tree-sitter</code> queries.
You can decide what to diff in the configuration, but let&rsquo;s go over it in an example:</p><p>So let&rsquo;s assume we update a fictional architecture.</p><p>We have an old <code>&lt;ARCH>Disassembler.c</code> file which might need an update.
In there we have a function which decodes an operand:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>decodeOperandA</span>(MCInst <span style=color:#f92672>*</span>MI, <span style=color:#66d9ef>unsigned</span> OpNum, <span style=color:#66d9ef>unsigned</span> Val) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>MCInst_isPredicable</span>(MI)) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MCOperand_CreateImm0</span>(MI, Val <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>MCOperand_CreateImm0</span>(MI, Val);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The same function in the <em>original</em> C++ file looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>decodeOperandA</span>(MCInst <span style=color:#f92672>&amp;</span>MI, <span style=color:#66d9ef>unsigned</span> OpNum, <span style=color:#66d9ef>unsigned</span> Val) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (MI.isPredicable()) {
</span></span><span style=display:flex><span>    MI.createImm(Val <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  MI.createImm(Val);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, after we ran the <code>CppTranslator</code> the result is almost valid C.
But the translation was not perfect and there is still a method invocation left:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>decodeOperandA</span>(MCInst <span style=color:#f92672>*</span>MI, <span style=color:#66d9ef>unsigned</span> OpNum, <span style=color:#66d9ef>unsigned</span> Val) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (MI.<span style=color:#a6e22e>isPredicable</span>()) { <span style=color:#75715e>// The isPredicable method call was not translated.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MCOperand_CreateImm0</span>(MI, Val <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>MCOperand_CreateImm0</span>(MI, Val);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Capstone&rsquo;s <code>MCInst</code> struct doesn&rsquo;t have a callback member <code>isPredicable()</code>. So this code would not compile.
Instead, we need to replace it with the function call <code>MCInst_isPredicable(MI)</code>.</p><p>For whatever reason no <code>Patch</code> was added, and we now have to fix it by hand.
Note though that the old file (see above) already has the correct function implementation.
So instead of fixing it again by hand, we diff the previous function to the newly translated code and let the user decide what to do.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>Patch: 15/230
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Node: &#34;Some Node&#34;
</span></span><span style=display:flex><span><span style=color:#a6e22e>+Color: NEW FILE - (Just translated)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#f92672>-Color: OLD FILE - (Currently in Capstone)
</span></span></span><span style=display:flex><span><span style=color:#f92672></span>
</span></span><span style=display:flex><span>⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼⎼
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void decodeOperandA(MCInst *MI, unsigned OpNum, unsigned Val) {
</span></span><span style=display:flex><span><span style=color:#f92672>-	if (MCInst_isPredicable(MI)) {
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+	if (MI.isPredicable()) {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>  	MCOperand_CreateImm0(MI, Val + 1);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>	MCOperand_CreateImm0(MI, Val);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>═════════════════════════════════════════════════════════════════════════════════════════════════════════
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Choice: O, o, n, s (none) , e, p, q, ? &gt; ?
</span></span><span style=display:flex><span>O		- Accept ALL old diffs
</span></span><span style=display:flex><span>o		- Accept old diff
</span></span><span style=display:flex><span>n		- Accept new diff
</span></span><span style=display:flex><span>e		- Edit diff (not yet implemented)
</span></span><span style=display:flex><span>s (none) 	- Select saved choice
</span></span><span style=display:flex><span>p		- Ignore and go to previous diff
</span></span><span style=display:flex><span>q		- Quit (previous selections will be saved)
</span></span><span style=display:flex><span>?		- Show this help
</span></span></code></pre></div><p>They can accept the version from the old file or accept the version from the new file.
The version from the new file would not compile, but it can be fixes by hand later.</p><p>In most cases though, the old version is the correct one, because it was fixed by someone before.</p><p>The diffing happens for each translated function which doesn&rsquo;t match the old code.
Of course, you can not just diff functions but any nodes in the AST of a file.
And for convenience the choices are saved as well. So if the update is run again and nothing changed, the user doesn&rsquo;t have to redo previous decisions.
It just automatically applies them.</p><p>This diffing step saves a lot of time.</p><h2 id=adding-new-architectures>Adding new architectures<a hidden class=anchor aria-hidden=true href=#adding-new-architectures>#</a></h2><p>Adding a new architecture module works pretty much the same as above.</p><p>Generally though it gives us a standardized way of doing it. And if you know one architecture module in Capstone, you know them all.
If LLVM doesn&rsquo;t support your architecture you maybe find a fork which does (this is the case for TriCore or EVM).</p><p>In fact, we added two niche architectures this way. TriCore was only implemented in a fork and never upstreamed.
And the <a href=https://en.wikipedia.org/wiki/DEC_Alpha>DEC Alpha</a> architecture support was dropped in LLVM 4.
We just added the <code>td</code> files again, and here we go, we have support for Alpha in Capstone.</p><h2 id=last-overview>Last overview<a hidden class=anchor aria-hidden=true href=#last-overview>#</a></h2><p>To give you a last overview what components were updated and how they interact in Capstone, take a look at this diagram:</p><pre tabindex=0><code>                                                                 ARCH_LLVM_getInstr(
                                     ARCH_getInstr(bytes)   ┌───┐   bytes)           ┌─────────┐            ┌──────────┐
                                    ┌──────────────────────►│ A ├──────────────────► │         ├───────────►│          ├────┐
                                    │                       │ R │                    │ LLVM    │            │ LLVM     │    │ Decode
                                    │                       │ C │                    │         │            │          │    │ Instr.
                                    │                       │ H │                    │         │decode(Op0) │          │◄───┘
┌────────┐ disasm(bytes) ┌──────────┴──┐                    │   │                    │ Disass- │ ◄──────────┤ Decoder  │
│CS Core ├──────────────►│ ARCH Module │                    │   │                    │ embler  ├──────────► │ State    │
└────────┘               └─────────────┘                    │ M │                    │         │            │ Machine  │
                                    ▲                       │ A │                    │         │decode(Op1) │          │
                                    │                       │ P │                    │         │ ◄──────────┤          │
                                    │                       │ P │                    │         ├──────────► │          │
                                    │                       │ I │                    │         │            │          │
                                    │                       │ N │                    │         │            │          │
                                    └───────────────────────┤ G │◄───────────────────┤         │◄───────────┤          │
                                                            └───┘                    └─────────┘            └──────────┘
</code></pre><p>The <code>Capstone Core</code>, <code>Arch Module</code> and <code>Arch_Mapping</code> provide the API to the LLVM disassembler logic.
We have not spoken about those because they are irrelevant for the topic of generating disassemblers.</p><p>The two boxes on the right, are the code copies from LLVM, which do the actual decoding work.
The <code>LLVM Disassembler</code> component decodes single operands and handles special cases. This one was translated by the <code>CppTranslator</code>.
While the <code>LLVM Decoder State Machine</code> was generated by our patched LLVM backends.</p><p>The same structure applies to the printing of the asm text. Though we have only scratched this here for the sake of brevity.</p><h2 id=wrap-up>Wrap up<a hidden class=anchor aria-hidden=true href=#wrap-up>#</a></h2><p>If one looks at the whole update procedure, it is still a rather complicated. But the result is worth it.</p><p>The amount of time someone has to spend for updating an architecture module in Capstone went down from &ldquo;no one did it&rdquo; to roughly 6-29 hours.
To update the ARM architecture module to LLVM 16 for example, the times were:</p><ol><li>Rebasing patched backends to new LLVM release = ~1-3h</li><li>Running the update scripts and diffing = 5min - 1h</li><li>Fixing rest of build errors by hand = ~30min - 5h</li><li>Handle new operands on the CS side (filling the detail info and tests) - 3-10h</li><li>Bug fixing - 2h-10h</li></ol><p>(Please be aware though, that the time estimates from above don&rsquo;t include the &ldquo;read into&rdquo; time someone has to spend).</p><p>The lower estimates are for small changes on the LLVM side, the upper for many changes (spanning multiple LLVM releases).</p><p>Here is process described above in action:</p><p><a href=https://asciinema.org/a/Vy0xmYku4qK4CL8kNvgDl3Lfn><img loading=lazy src=https://asciinema.org/a/Vy0xmYku4qK4CL8kNvgDl3Lfn.svg alt=asciicast></a></p><h2 id=future-plans>Future plans<a hidden class=anchor aria-hidden=true href=#future-plans>#</a></h2><p>We have a list of features and architectures which will come.
Most architectures are already updated, but <code>ARC</code>, <code>BPF</code> and <code>SPARC</code> are still on <a href=https://github.com/capstone-engine/capstone/issues/2015>the list</a>.</p><p>While working on the updater we found many shortcomings or flaws in the target definitions in LLVM.
Those will be upstreamed to LLVM eventually.</p><p>In the very long run we would like to participate with the LLVM folks in redesign the TableGen backends.
It would be nice to have the problems solved, which we mentioned above.</p><p>And of course, if you want to update now an already present Capstone module or add support for a new one, feel free to drop a message in <a href=https://github.com/capstone-engine/capstone/issues/2015>issue #2015</a>.
We are happy to hear about it and will guide you through the process.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://github.com/capstone-engine/capstone/issues/2015>Auto-Sync progress issue</a></li><li><a href=https://github.com/capstone-engine/capstone/blob/next/docs/AutoSync.md>Auto-Sync documentation</a></li><li><a href=https://llvm.org/docs/TableGen/>TableGen documentation</a></li><li><a href=https://github.com/capstone-engine/llvm-capstone>Capstone&rsquo;s LLVM fork</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://rizin.re/tags/dev/>dev</a></li><li><a href=https://rizin.re/tags/rizin/>rizin</a></li><li><a href=https://rizin.re/tags/capstone/>capstone</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Auto-Sync - Generating disassembler plugins on twitter" href="https://twitter.com/intent/tweet/?text=Auto-Sync%20-%20Generating%20disassembler%20plugins&amp;url=https%3a%2f%2frizin.re%2fposts%2fauto-sync%2f&amp;hashtags=dev%2crizin%2ccapstone"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Auto-Sync - Generating disassembler plugins on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frizin.re%2fposts%2fauto-sync%2f&amp;title=Auto-Sync%20-%20Generating%20disassembler%20plugins&amp;summary=Auto-Sync%20-%20Generating%20disassembler%20plugins&amp;source=https%3a%2f%2frizin.re%2fposts%2fauto-sync%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Auto-Sync - Generating disassembler plugins on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frizin.re%2fposts%2fauto-sync%2f&title=Auto-Sync%20-%20Generating%20disassembler%20plugins"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Auto-Sync - Generating disassembler plugins on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frizin.re%2fposts%2fauto-sync%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Auto-Sync - Generating disassembler plugins on whatsapp" href="https://api.whatsapp.com/send?text=Auto-Sync%20-%20Generating%20disassembler%20plugins%20-%20https%3a%2f%2frizin.re%2fposts%2fauto-sync%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Auto-Sync - Generating disassembler plugins on telegram" href="https://telegram.me/share/url?text=Auto-Sync%20-%20Generating%20disassembler%20plugins&amp;url=https%3a%2f%2frizin.re%2fposts%2fauto-sync%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://rizin.re/>Rizin</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script defer src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById("menu").scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})});function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById("menu").scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>