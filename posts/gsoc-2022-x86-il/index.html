<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GSoC 2022 - x86 ISA lifting for RzIL | Rizin</title><meta name=keywords content="rizin,gsoc"><meta name=description content="A summary of all the work done on RzIL lifting for x86 ISA, and how you can use it."><meta name=author content="DMaroo"><link rel=canonical href=https://rizin.re/posts/gsoc-2022-x86-il/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://rizin.re/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://rizin.re/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://rizin.re/favicon-32x32.png><link rel=apple-touch-icon href=https://rizin.re/apple-touch-icon.png><link rel=mask-icon href=https://rizin.re/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link href=https://cdn.lineicons.com/2.0/LineIcons.css rel=stylesheet><link rel=stylesheet href=https://rizin.re/css/custom/rizin.min.f00018437c0f0fe081c2a5ccdb294666c6f0adc5f7ca5ce6f622496f40fc88ac.css><meta property="og:title" content="GSoC 2022 - x86 ISA lifting for RzIL"><meta property="og:description" content="A summary of all the work done on RzIL lifting for x86 ISA, and how you can use it."><meta property="og:type" content="article"><meta property="og:url" content="https://rizin.re/posts/gsoc-2022-x86-il/"><meta property="og:image" content="https://rizin.re/images/rizin_preview.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-04T00:00:00+00:00"><meta property="article:modified_time" content="2022-12-04T00:00:00+00:00"><meta property="og:site_name" content="Rizin"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rizin.re/images/rizin_preview.png"><meta name=twitter:title content="GSoC 2022 - x86 ISA lifting for RzIL"><meta name=twitter:description content="A summary of all the work done on RzIL lifting for x86 ISA, and how you can use it."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://rizin.re/posts/"},{"@type":"ListItem","position":2,"name":"GSoC 2022 - x86 ISA lifting for RzIL","item":"https://rizin.re/posts/gsoc-2022-x86-il/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GSoC 2022 - x86 ISA lifting for RzIL","name":"GSoC 2022 - x86 ISA lifting for RzIL","description":"A summary of all the work done on RzIL lifting for x86 ISA, and how you can use it.","keywords":["rizin","gsoc"],"articleBody":"Hi! I’m DMaroo, a GSoC 2022 mentee, working on IL migration for x86 ISA in Rizin. For the past few months, I have worked on implementing x86 instructions (from 8086, 80186, 80286 and 80386 instruction sets) in Rizin’s intermediate language, RzIL.\nThe following article covers all the work, design decisions, challenges and future plans of the work that I’ve been doing. The RzIL can be accessed using aez commands (RzIL emulation).\nRelevant code Implementation of RzIL lifting for x86 instructions:\nPull request: rizinorg/rizin#2747 Commit: ce80a13 Files: x86_il.c, x86_il.h Adding tracing for x86 emulation in BAP’s QEMU: BinaryAnalysisPlatform/qemu#21\nAbstract RzIL is Rizin’s intermediate language. It is designed for improved analysis of binaries by serving as an intermediate language to run the analysis loop on. This removes the need to write architecture-specific analysis code. Having an intermediate language also allows for many other features like taint analysis, symbolic execution and de-obfuscation.\nMy goal for the project was to “lift” the x86 architecture to RzIL. Lifting here means implementing the x86 instructions from the x86 ISA using opcodes present in the IL. The IL is largely based on BAP’s Core Theory.\nThroughout my GSoC period, I have lifted x86 instructions for majority of the instructions belonging in the 8086, 80186, 80286 and 80386 instruction sets. These include almost all the commonly used instructions one can find in modern x86 binaries, and hence would be enough to do fairly satisfactory analysis. I outline my work in detail below.\nWork Getting instructions from Capstone Rizin uses Capstone for the disassembly of some of the instruction sets, including x86. So I had to start off by figuring out all the information that Capstone gives about an instruction. Capstone returns a cs_x86 struct which contains the instruction bytes, operands, prefixes and other data. I wrapped it in a X86ILIns struct for convenience. Once I had the wrappers ready, I had to write general helper functions for generating the opcodes for variety of tasks like for getting and setting the operands, registers, memory, flags, and arithmetic overflow and so on.\nSetting up the helper functions I have conceptually outlined the rough thought process for the IL lifting in one of the posts on my blog about SuperH IL lifting. Following a similar design process, I set up the functions to get and set the various entities involved. I also set up th functions for overflow/underflow and carry/borrow. More about the challenges faced during setting up these functions in the challenges section. Once these were setup, the lifting was just reading the implementations off of the ISA manual and translating them to the IL.\nImplementing the instructions This is probably the main part of the whole project. Now, I was supposed to go through the instruction manual’s implementation for all the instructions and convert them to the IL. I could not however just blindly copy them, since the x86 instruction set frequently contains instructions with very weird special cases. Also, the x86 architecture is not simple, and contains multiple modes of operation, and also has segmentation and paging support. All of this makes it non-trivial to implement the instructions. Many of the instructions are not practically possible to implement given the current scope of the IL and the disassembler.\nHowever, I did implement majority of the instructions in the 8086, 80186, 80286 and 80486 instruction set. That constitutes the meat of all the instructions used in x86 binaries. There are much more very specific and exotic instructions, but their relevance is diminishingly low. A sample implementation looks as follows:\n/** * ADD dest, src * (ADD family of instructions) * Add * dest = dest + src * Possible encodings: * - I * - MI * - MR * - RM */ IL_LIFTER(add) { RzILOpEffect *op1 = SETL(\"op1\", x86_il_get_op(0)); RzILOpEffect *op2 = SETL(\"op2\", x86_il_get_op(1)); RzILOpEffect *sum = SETL(\"sum\", ADD(VARL(\"op1\"), VARL(\"op2\"))); RzILOpEffect *set_dest = x86_il_set_op(0, VARL(\"sum\")); RzILOpEffect *set_res_flags = x86_il_set_result_flags(VARL(\"sum\")); RzILOpEffect *set_arith_flags = x86_il_set_arithmetic_flags(VARL(\"sum\"), VARL(\"op1\"), VARL(\"op2\"), true); return SEQ6(op1, op2, sum, set_dest, set_res_flags, set_arith_flags); } And the generated opcode looks something like this:\nadd byte [eax], al (seq (set op1 (loadw 0 8 (+ (var eax) (bv 32 0x0)))) (set op2 (cast 8 false (var eax))) (set sum (+ (var op1) (var op2))) (storew 0 (+ (var eax) (bv 32 0x0)) (var sum)) (set _result (var sum)) (set _popcnt (bv 8 0x0)) (set _val (cast 8 false (var _result))) (repeat (is_zero (var _val)) (seq (set _popcnt (+ (var _popcnt) (ite (lsb (var _val)) (bv 8 0x1) (bv 8 0x0)))) (set _val (\u003e\u003e (var _val) (bv 8 0x1) false)))) (set pf (is_zero (smod (var _popcnt) (bv 8 0x2)))) (set zf (is_zero (var _result))) (set sf (msb (var _result))) (set _result (var sum)) (set _x (var op1)) (set _y (var op2)) (set cf (|| (|| (\u0026\u0026 (msb (var _x)) (msb (var _y))) (\u0026\u0026 (! (msb (var _result))) (msb (var _y)))) (\u0026\u0026 (msb (var _x)) (! (msb (var _result)))))) (set of (|| (\u0026\u0026 (\u0026\u0026 (! (msb (var _result))) (msb (var _x))) (msb (var _y))) (\u0026\u0026 (\u0026\u0026 (msb (var _result)) (! (msb (var _x)))) (! (msb (var _y)))))) (set af (|| (|| (\u0026\u0026 (msb (cast 4 false (var _x))) (msb (cast 4 false (var _y)))) (\u0026\u0026 (! (msb (cast 4 false (var _result)))) (msb (cast 4 false (var _y))))) (\u0026\u0026 (msb (cast 4 false (var _x))) (! (msb (cast 4 false (var _result)))))))) As you can see, the IL is quite large even for a simple instruction like ADD. This is because of all the extra work which needs to be done other than just adding the operands. The operand needs to be loaded from the proper memory location (which requires using the correct segment base register, correct scale and correct offset). Once the addition is done, the flags need to be set. Setting the flags is not a simple operation since it requires finding the parity bit (which requires XORing the bits in a loop). Once all the flag bits are set, the result is written back to the memory.\nAs of this post, 100+ such instructions have been lifted to the IL. There are more instructions to be lifted as well, but as I stated above, these are enough for a start and testing.\nOnce I was done with implementing the instructions, I added IL tests for the implemented instructions for the tests in tests/db/asm/x86_*. This part ensures that the generated IL code for the instructions is type-safe and doesn’t have any memory issues.\nEnabling tracing in QEMU Now to verify the semantics of the IL instructions, we use traces generated by QEMU and compare them with the effects of teh IL when executed by the RzIL VM. We use a fork of QEMU, so that we can add the tracing code and modify QEMU source if needed. To add the tracing code, I had to familiarize myself with QEMU’s code, and specifically the TCG (Tiny Code Generator). Currently, adding the tracing has been almost done. However, there are just some very minor issues which need to be resolved.\nChallenges This is more of an interesting-stuff kinda section ;)\nRegisters Choosing the correct registers without a chain of if-else statements or switch-case statements was one of the initial issues I faced. Not only do I have to resolve to the correct register, I should also be able to store and load from the same global IL variable when I reference different sections of a register (i.e. AL, AX, EAX and RAX overlap over the same global IL variable). Along with this, I should also have the ability to choose the largest register of a certain bitness (for example, RAX for 64-bit, EAX for 32-bit and AX for 16-bit) without using switch-case statements. I decided to do this using a statically defined array of registers and their get and set functions (gpr_lookup_table, array of struct gpr_lookup_helper_t). This lead to no sort of if-else or switch-case constructs, and I could reuse the same functions for getting and setting the same sections o a register.\nOperands Also, there had to be a general interface for accessing the operands, irrespective of whether they were a register, or a memory location, or an immediate value. Writing the helper functions is easy, but providing ease of usage and removing duplication code requires thought. I have also slightly touched upon this in the SuperH IL lifting post on my blog.\nIL implementation The descriptions in the x86 manual for some instructions get pretty complex and intense. Making sure that they are implemented correctly is not easy. This is exactly why we have tracetesting to verify the semantics, but manual verification never hurts. Also, the IL gets pretty large for many instructions, and to avoid this, it is important to choose a semantically correct, yet concise implementation. This involves removing unnecessary casting, using loops, removing duplicating and so on. In fact, removing duplication by using variables brings down the IL code size by a lot.\nQEMU QEMU’s codebase is a great for learning purposes. It consists of complex C constructs (tons of non-trivial preprocessor macros), but at the same time it is quite well-written, and also reasonably well documented. However, debugging the codebase is not that easy, since the code generates a buffer (code_gen_buffer), which then executes more code.\nFuture Work The work I have done in my duration is just the core part of the lifting. The lifting is far from being stable and ready-to-use. It is more of an pre-alpha release than a finished feature. The next steps will be as follows.\nTracetest: Thoroughly tracetest the implementations to make sure the semantics are right. API: Add Rizin commands and API, which would be wrappers around the IL, so as to visualize and access the IL. A similar graphical widget should also be added to Cutter. Documentation: Document the IL and its usage in the Rizin book. Analysis: Integrate the IL in the analysis loop to lead to a better analysis. Instructions: Add lifting for more x86 instructions. The last two options haven’t been thoroughly thought out by me yet, but they do seem to be reasonable future goals. Alongside, there are also plans on lifting other architectures to RzIL and extending RzIL by adding floating point and transcendental operations support.\nClosure I would say that I had a very educative experience throughout the period. I learnt quite a lot about the x86 architecture and the instruction set in the past few months. I was not able to meet all my goals for my GSoC project, but I think the work done until now is a good enough checkpoint and I plan to continue working on this.\nI would like to thank my mentors, Anton Kochkov, Deroad and Florian Märkl, for all the guidance they have provided me throughout my project. I look forward to keep working with them :)\n","wordCount":"1802","inLanguage":"en","datePublished":"2022-12-04T00:00:00Z","dateModified":"2022-12-04T00:00:00Z","author":{"@type":"Person","name":"DMaroo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://rizin.re/posts/gsoc-2022-x86-il/"},"publisher":{"@type":"Organization","name":"Rizin","logo":{"@type":"ImageObject","url":"https://rizin.re/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>.theme-toggle{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://rizin.re/ accesskey=h>Rizin</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t title="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://rizin.re/posts/ target><span>Blog</span></a></li><li><a href=https://rizin.re/organization/ target><span>Organization</span></a></li><li><a href=https://rizin.re/community/ target><span>Community</span></a></li><li><a href=https://rizin.re/gsoc/ target><span>GSoC</span></a></li><li><a href=https://cutter.re target=_blank><span>Cutter</span></a></li><li><a href=https://github.com/rizinorg/rizin target=_blank><i class="lni lni-github-original"></i>
<span>Source</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://rizin.re/>Home</a>&nbsp;»&nbsp;<a href=https://rizin.re/posts/>Posts</a></div><h1 class=post-title>GSoC 2022 - x86 ISA lifting for RzIL</h1><div class=post-meta><span title='2022-12-04 00:00:00 +0000 UTC'>December 4, 2022</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;DMaroo</div></header><div class=post-content><p>Hi! I&rsquo;m <a href=https://github.com/DMaroo>DMaroo</a>, a GSoC 2022 mentee, working on IL migration for x86 ISA in Rizin. For the past few months, I have worked on implementing x86 instructions (from 8086, 80186, 80286 and 80386 instruction sets) in Rizin&rsquo;s intermediate language, <a href=https://github.com/rizinorg/rizin/blob/dev/doc/rzil.md>RzIL</a>.</p><p>The following article covers all the work, design decisions, challenges and future plans of the work that I&rsquo;ve been doing. The RzIL can be accessed using <code>aez</code> commands (RzIL emulation).</p><h2 id=relevant-code>Relevant code<a hidden class=anchor aria-hidden=true href=#relevant-code>#</a></h2><p>Implementation of RzIL lifting for x86 instructions:</p><ul><li><em>Pull request:</em> <a href=https://github.com/rizinorg/rizin/pull/2747>rizinorg/rizin#2747</a></li><li><em>Commit:</em> <a href=https://github.com/rizinorg/rizin/commit/ce80a13aed3b036c73ac9eb1b6365a525900f7d7><code>ce80a13</code></a></li><li><em>Files:</em> <a href=https://github.com/rizinorg/rizin/blob/dev/librz/analysis/arch/x86/x86_il.c>x86_il.c</a>, <a href=https://github.com/rizinorg/rizin/blob/dev/librz/analysis/arch/x86/x86_il.h>x86_il.h</a></li></ul><p>Adding tracing for x86 emulation in BAP&rsquo;s QEMU: <a href=https://github.com/BinaryAnalysisPlatform/qemu/pull/21>BinaryAnalysisPlatform/qemu#21</a></p><h1 id=abstract>Abstract<a hidden class=anchor aria-hidden=true href=#abstract>#</a></h1><p><a href=https://github.com/rizinorg/rizin/blob/dev/doc/rzil.md>RzIL</a> is Rizin&rsquo;s intermediate language. It is designed for improved analysis of binaries by serving as an intermediate language to run the analysis loop on. This removes the need to write architecture-specific analysis code. Having an intermediate language also allows for many other features like taint analysis, symbolic execution and de-obfuscation.</p><p>My goal for the project was to &ldquo;lift&rdquo; the x86 architecture to RzIL. Lifting here means implementing the x86 instructions from the x86 ISA using opcodes present in the IL. The IL is largely based on <a href=https://binaryanalysisplatform.github.io/bap/api/master/bap-core-theory/Bap_core_theory/Theory/index.html>BAP&rsquo;s Core Theory</a>.</p><p>Throughout my GSoC period, I have lifted x86 instructions for majority of the instructions belonging in the 8086, 80186, 80286 and 80386 instruction sets. These include almost all the commonly used instructions one can find in modern x86 binaries, and hence would be enough to do fairly satisfactory analysis. I outline my work in detail below.</p><h1 id=work>Work<a hidden class=anchor aria-hidden=true href=#work>#</a></h1><h2 id=getting-instructions-from-capstone>Getting instructions from Capstone<a hidden class=anchor aria-hidden=true href=#getting-instructions-from-capstone>#</a></h2><p>Rizin uses <a href=https://www.capstone-engine.org/>Capstone</a> for the disassembly of some of the instruction sets, including x86. So I had to start off by figuring out all the information that Capstone gives about an instruction. Capstone returns a <code>cs_x86</code> struct which contains the instruction bytes, operands, prefixes and other data. I wrapped it in a <code>X86ILIns</code> struct for convenience. Once I had the wrappers ready, I had to write general helper functions for generating the opcodes for variety of tasks like for getting and setting the operands, registers, memory, flags, and arithmetic overflow and so on.</p><h2 id=setting-up-the-helper-functions>Setting up the helper functions<a hidden class=anchor aria-hidden=true href=#setting-up-the-helper-functions>#</a></h2><p>I have conceptually outlined the rough thought process for the IL lifting in one of the posts on <a href=https://dmaroo.github.io/>my blog</a> about <a href=https://dmaroo.github.io/superhlifting>SuperH IL lifting</a>. Following a similar design process, I set up the functions to get and set the various entities involved. I also set up th functions for overflow/underflow and carry/borrow. More about the challenges faced during setting up these functions in the <a href=#challenges>challenges</a> section. Once these were setup, the lifting was just reading the implementations off of the ISA manual and translating them to the IL.</p><h2 id=implementing-the-instructions>Implementing the instructions<a hidden class=anchor aria-hidden=true href=#implementing-the-instructions>#</a></h2><p>This is probably the main part of the whole project. Now, I was supposed to go through the instruction manual&rsquo;s implementation for all the instructions and convert them to the IL. I could not however just blindly copy them, since the x86 instruction set frequently contains instructions with very weird special cases. Also, the x86 architecture is not simple, and contains multiple modes of operation, and also has segmentation and paging support. All of this makes it non-trivial to implement the instructions. Many of the instructions are not practically possible to implement given the current scope of the IL and the disassembler.</p><p>However, I did implement majority of the instructions in the 8086, 80186, 80286 and 80486 instruction set. That constitutes the meat of all the instructions used in x86 binaries. There are much more very specific and exotic instructions, but their relevance is diminishingly low. A sample implementation looks as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * ADD  dest, src
</span></span></span><span style=display:flex><span><span style=color:#75715e> * (ADD family of instructions)
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Add
</span></span></span><span style=display:flex><span><span style=color:#75715e> * dest = dest + src
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Possible encodings:
</span></span></span><span style=display:flex><span><span style=color:#75715e> *  - I
</span></span></span><span style=display:flex><span><span style=color:#75715e> *  - MI
</span></span></span><span style=display:flex><span><span style=color:#75715e> *  - MR
</span></span></span><span style=display:flex><span><span style=color:#75715e> *  - RM
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>IL_LIFTER</span>(add) {
</span></span><span style=display:flex><span>	RzILOpEffect <span style=color:#f92672>*</span>op1 <span style=color:#f92672>=</span> <span style=color:#a6e22e>SETL</span>(<span style=color:#e6db74>&#34;op1&#34;</span>, <span style=color:#a6e22e>x86_il_get_op</span>(<span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>	RzILOpEffect <span style=color:#f92672>*</span>op2 <span style=color:#f92672>=</span> <span style=color:#a6e22e>SETL</span>(<span style=color:#e6db74>&#34;op2&#34;</span>, <span style=color:#a6e22e>x86_il_get_op</span>(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>	RzILOpEffect <span style=color:#f92672>*</span>sum <span style=color:#f92672>=</span> <span style=color:#a6e22e>SETL</span>(<span style=color:#e6db74>&#34;sum&#34;</span>, <span style=color:#a6e22e>ADD</span>(<span style=color:#a6e22e>VARL</span>(<span style=color:#e6db74>&#34;op1&#34;</span>), <span style=color:#a6e22e>VARL</span>(<span style=color:#e6db74>&#34;op2&#34;</span>)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	RzILOpEffect <span style=color:#f92672>*</span>set_dest <span style=color:#f92672>=</span> <span style=color:#a6e22e>x86_il_set_op</span>(<span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>VARL</span>(<span style=color:#e6db74>&#34;sum&#34;</span>));
</span></span><span style=display:flex><span>	RzILOpEffect <span style=color:#f92672>*</span>set_res_flags <span style=color:#f92672>=</span> <span style=color:#a6e22e>x86_il_set_result_flags</span>(<span style=color:#a6e22e>VARL</span>(<span style=color:#e6db74>&#34;sum&#34;</span>));
</span></span><span style=display:flex><span>	RzILOpEffect <span style=color:#f92672>*</span>set_arith_flags <span style=color:#f92672>=</span> <span style=color:#a6e22e>x86_il_set_arithmetic_flags</span>(<span style=color:#a6e22e>VARL</span>(<span style=color:#e6db74>&#34;sum&#34;</span>), <span style=color:#a6e22e>VARL</span>(<span style=color:#e6db74>&#34;op1&#34;</span>), <span style=color:#a6e22e>VARL</span>(<span style=color:#e6db74>&#34;op2&#34;</span>), true);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>SEQ6</span>(op1, op2, sum, set_dest, set_res_flags, set_arith_flags);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And the generated opcode looks something like this:</p><pre tabindex=0><code>add byte [eax], al

(seq (set op1 (loadw 0 8 (+ (var eax) (bv 32 0x0)))) (set op2 (cast 8 false (var eax))) (set sum (+ (var op1) (var op2))) (storew 0 (+ (var eax) (bv 32 0x0)) (var sum)) (set _result (var sum)) (set _popcnt (bv 8 0x0)) (set _val (cast 8 false (var _result))) (repeat (is_zero (var _val)) (seq (set _popcnt (+ (var _popcnt) (ite (lsb (var _val)) (bv 8 0x1) (bv 8 0x0)))) (set _val (&gt;&gt; (var _val) (bv 8 0x1) false)))) (set pf (is_zero (smod (var _popcnt) (bv 8 0x2)))) (set zf (is_zero (var _result))) (set sf (msb (var _result))) (set _result (var sum)) (set _x (var op1)) (set _y (var op2)) (set cf (|| (|| (&amp;&amp; (msb (var _x)) (msb (var _y))) (&amp;&amp; (! (msb (var _result))) (msb (var _y)))) (&amp;&amp; (msb (var _x)) (! (msb (var _result)))))) (set of (|| (&amp;&amp; (&amp;&amp; (! (msb (var _result))) (msb (var _x))) (msb (var _y))) (&amp;&amp; (&amp;&amp; (msb (var _result)) (! (msb (var _x)))) (! (msb (var _y)))))) (set af (|| (|| (&amp;&amp; (msb (cast 4 false (var _x))) (msb (cast 4 false (var _y)))) (&amp;&amp; (! (msb (cast 4 false (var _result)))) (msb (cast 4 false (var _y))))) (&amp;&amp; (msb (cast 4 false (var _x))) (! (msb (cast 4 false (var _result))))))))
</code></pre><p>As you can see, the IL is quite large even for a simple instruction like <code>ADD</code>. This is because of all the extra work which needs to be done other than just adding the operands. The operand needs to be loaded from the proper memory location (which requires using the correct segment base register, correct scale and correct offset). Once the addition is done, the flags need to be set. Setting the flags is not a simple operation since it requires finding the parity bit (which requires XORing the bits in a loop). Once all the flag bits are set, the result is written back to the memory.</p><p>As of this post, 100+ such instructions have been lifted to the IL. There are more instructions to be lifted as well, but as I stated above, these are enough for a start and testing.</p><p>Once I was done with implementing the instructions, I added IL tests for the implemented instructions for the tests in <code>tests/db/asm/x86_*</code>. This part ensures that the generated IL code for the instructions is type-safe and doesn&rsquo;t have any memory issues.</p><h2 id=enabling-tracing-in-qemu>Enabling tracing in QEMU<a hidden class=anchor aria-hidden=true href=#enabling-tracing-in-qemu>#</a></h2><p>Now to verify the semantics of the IL instructions, we use traces generated by QEMU and compare them with the effects of teh IL when executed by the RzIL VM. We use a <a href=https://github.com/BinaryAnalysisPlatform/qemu>fork of QEMU</a>, so that we can add the tracing code and modify QEMU source if needed. To add the tracing code, I had to familiarize myself with QEMU&rsquo;s code, and specifically the <a href=https://wiki.qemu.org/Documentation/TCG>TCG (Tiny Code Generator)</a>. Currently, adding the tracing has been almost done. However, there are just some very minor issues which need to be resolved.</p><h1 id=challenges>Challenges<a hidden class=anchor aria-hidden=true href=#challenges>#</a></h1><p>This is more of an interesting-stuff kinda section ;)</p><h2 id=registers>Registers<a hidden class=anchor aria-hidden=true href=#registers>#</a></h2><p>Choosing the correct registers without a chain of if-else statements or switch-case statements was one of the initial issues I faced. Not only do I have to resolve to the correct register, I should also be able to store and load from the same global IL variable when I reference different sections of a register (i.e. <code>AL</code>, <code>AX</code>, <code>EAX</code> and <code>RAX</code> overlap over the same global IL variable). Along with this, I should also have the ability to choose the largest register of a certain bitness (for example, <code>RAX</code> for 64-bit, <code>EAX</code> for 32-bit and <code>AX</code> for 16-bit) without using switch-case statements. I decided to do this using a statically defined array of registers and their get and set functions (<code>gpr_lookup_table</code>, array of <code>struct gpr_lookup_helper_t</code>). This lead to no sort of if-else or switch-case constructs, and I could reuse the same functions for getting and setting the same sections o a register.</p><h2 id=operands>Operands<a hidden class=anchor aria-hidden=true href=#operands>#</a></h2><p>Also, there had to be a general interface for accessing the operands, irrespective of whether they were a register, or a memory location, or an immediate value. Writing the helper functions is easy, but providing ease of usage and removing duplication code requires thought. I have also slightly touched upon this in the <a href=https://dmaroo.github.io/superhlifting>SuperH IL lifting post</a> on <a href=https://dmaroo.github.io/>my blog</a>.</p><h2 id=il-implementation>IL implementation<a hidden class=anchor aria-hidden=true href=#il-implementation>#</a></h2><p>The descriptions in the x86 manual for some instructions get pretty complex and intense. Making sure that they are implemented correctly is not easy. This is exactly why we have tracetesting to verify the semantics, but manual verification never hurts. Also, the IL gets pretty large for many instructions, and to avoid this, it is important to choose a semantically correct, yet concise implementation. This involves removing unnecessary casting, using loops, removing duplicating and so on. In fact, removing duplication by using variables brings down the IL code size by a lot.</p><h2 id=qemu>QEMU<a hidden class=anchor aria-hidden=true href=#qemu>#</a></h2><p>QEMU&rsquo;s codebase is a great for learning purposes. It consists of complex C constructs (tons of non-trivial preprocessor macros), but at the same time it is quite well-written, and also reasonably well documented. However, debugging the codebase is not that easy, since the code generates a buffer (<code>code_gen_buffer</code>), which then executes more code.</p><h1 id=future-work>Future Work<a hidden class=anchor aria-hidden=true href=#future-work>#</a></h1><p>The work I have done in my duration is just the core part of the lifting. The lifting is far from being stable and ready-to-use. It is more of an pre-alpha release than a finished feature. The next steps will be as follows.</p><ul><li><strong>Tracetest</strong>: Thoroughly tracetest the implementations to make sure the semantics are right.</li><li><strong>API</strong>: Add Rizin commands and API, which would be wrappers around the IL, so as to visualize and access the IL. A similar graphical widget should also be added to Cutter.</li><li><strong>Documentation</strong>: Document the IL and its usage in the Rizin book.</li><li><strong>Analysis</strong>: Integrate the IL in the analysis loop to lead to a better analysis.</li><li><strong>Instructions</strong>: Add lifting for more x86 instructions.</li></ul><p>The last two options haven&rsquo;t been thoroughly thought out by me yet, but they do seem to be reasonable future goals. Alongside, there are also plans on <a href=https://github.com/rizinorg/rizin/issues/2080>lifting other architectures to RzIL</a> and extending RzIL by <a href=https://github.com/rizinorg/rizin/issues/1461>adding floating point and transcendental operations support</a>.</p><h1 id=closure>Closure<a hidden class=anchor aria-hidden=true href=#closure>#</a></h1><p>I would say that I had a very educative experience throughout the period. I learnt quite a lot about the x86 architecture and the instruction set in the past few months. I was not able to meet all my goals for my GSoC project, but I think the work done until now is a good enough checkpoint and I plan to continue working on this.</p><p>I would like to thank my mentors, <a href=https://github.com/XVilka>Anton Kochkov</a>, <a href=https://github.com/wargio>Deroad</a> and <a href=https://github.com/thestr4ng3r>Florian Märkl</a>, for all the guidance they have provided me throughout my project. I look forward to keep working with them :)</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://rizin.re/tags/rizin/>rizin</a></li><li><a href=https://rizin.re/tags/gsoc/>gsoc</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share GSoC 2022 - x86 ISA lifting for RzIL on twitter" href="https://twitter.com/intent/tweet/?text=GSoC%202022%20-%20x86%20ISA%20lifting%20for%20RzIL&amp;url=https%3a%2f%2frizin.re%2fposts%2fgsoc-2022-x86-il%2f&amp;hashtags=rizin%2cgsoc"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share GSoC 2022 - x86 ISA lifting for RzIL on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2frizin.re%2fposts%2fgsoc-2022-x86-il%2f&amp;title=GSoC%202022%20-%20x86%20ISA%20lifting%20for%20RzIL&amp;summary=GSoC%202022%20-%20x86%20ISA%20lifting%20for%20RzIL&amp;source=https%3a%2f%2frizin.re%2fposts%2fgsoc-2022-x86-il%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share GSoC 2022 - x86 ISA lifting for RzIL on reddit" href="https://reddit.com/submit?url=https%3a%2f%2frizin.re%2fposts%2fgsoc-2022-x86-il%2f&title=GSoC%202022%20-%20x86%20ISA%20lifting%20for%20RzIL"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share GSoC 2022 - x86 ISA lifting for RzIL on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2frizin.re%2fposts%2fgsoc-2022-x86-il%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share GSoC 2022 - x86 ISA lifting for RzIL on whatsapp" href="https://api.whatsapp.com/send?text=GSoC%202022%20-%20x86%20ISA%20lifting%20for%20RzIL%20-%20https%3a%2f%2frizin.re%2fposts%2fgsoc-2022-x86-il%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share GSoC 2022 - x86 ISA lifting for RzIL on telegram" href="https://telegram.me/share/url?text=GSoC%202022%20-%20x86%20ISA%20lifting%20for%20RzIL&amp;url=https%3a%2f%2frizin.re%2fposts%2fgsoc-2022-x86-il%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://rizin.re/>Rizin</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><script defer src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById("menu").scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})});function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById("menu").scrollLeft)}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>